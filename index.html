<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Browser Metronome</title>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0; padding: 2rem;
      background: #f0f2f5; color: #333;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 { margin-bottom: 1.5rem; }
    .controls {
      width: 100%; max-width: 700px;
      display: flex; flex-direction: column; gap: 1.5rem;
    }
    fieldset.section {
      background: #fff; border: none;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      padding: 1rem;
    }
    legend { font-weight: bold; padding: 0 0.5rem; }
    .group {
      display: flex; flex-wrap: wrap; gap: 1rem;
      align-items: center; margin-top: 0.5rem;
    }
    .group label,
    .group button,
    .group select,
    .group input[type='number'],
    .group input[type='range'],
    .group input[type='checkbox'] {
      font-size: 1rem; padding: 0.5rem;
      border: 1px solid #ccc; border-radius: 4px;
      background: #fafafa;
    }
    .group input[type='checkbox'] { width: auto; }
    #start { background: #4CAF50; color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; }
    #start:hover { background:#45A049; }
    #addChange { background:#4CAF50; color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; }
    #addChange:hover { background:#45A049; }
    #notation { margin-top:2rem; border:1px solid #ccc; background:#fff; }
    table { width:100%; border-collapse:collapse; margin-top:0.5rem; }
    th,td { border:1px solid #ddd; padding:0.5rem; text-align:center; }
    th { background:#f7f7f7; }
    .remove-change { background:#e74c3c; color:#fff; border:none; padding:0.25rem 0.5rem; cursor:pointer; }
    .remove-change:hover { background:#c0392b; }
    #accentPattern label { display:inline-flex; align-items:center; margin-right:0.5rem; }
    #accentPattern select { margin-left:0.25rem; }
    .beat-flash { animation: flash 0.1s ease-out; }
    .sub-flash { animation: subFlash 0.1s ease-out; }
    @keyframes flash {
      0% { background: #4CAF50; }
      100% { background: none; }
    }
    @keyframes subFlash {
      0% { background: #90CAF9; }
      100% { background: none; }
    }
  </style>
</head>
<body>
  <h1>Browser Metronome</h1>
  <div class="controls">
    <fieldset class="section">
      <legend>Tempo</legend>
      <div class="group">
        <label for="bpm">BPM:</label>
        <input type="number" id="bpm" value="100" min="30" max="300">
        <button id="tap" aria-label="Tap to set tempo">Tap Tempo</button>
        <button id="start" aria-label="Start metronome">Start</button>
        <button id="stop" disabled aria-label="Stop metronome">Stop</button>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Meter &amp; Subdivision</legend>
      <div class="group">
        <label for="timeSignature">Time Signature:</label>
        <select id="timeSignature" aria-label="Time signature">
          <option>2/4</option><option>3/4</option><option selected>4/4</option>
          <option>5/4</option><option>8/4</option><option>6/8</option><option>7/8</option>
          <option>9/8</option><option>11/8</option><option>12/8</option><option>13/8</option>
          <option>16/16</option>
        </select>
        <label for="subdivision">Subdivision:</label>
        <select id="subdivision" aria-label="Beat subdivision">
          <option value="1">None</option>
          <option value="2">8th</option>
          <option value="3">Triplet</option>
          <option value="4">16th</option>
          <option value="5">Quintuplet</option>
        </select>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Accent Grouping</legend>
      <div class="group">
        <label>Grouping Pattern:</label>
        <select id="grouping" aria-label="Accent grouping pattern"><option value="">—Manual—</option></select>
        <div id="accentPattern"></div>
      </div>
      <div class="group">
        <label>Default Accent Tone:</label>
        <select id="accentTone" aria-label="Default accent sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Tones &amp; Levels</legend>
      <div class="group">
        <label>Main Tone:</label>
        <select id="tone" aria-label="Main beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label>Main Volume:</label>
        <input type="range" id="volume" min="0" max="1" step="0.01" value="1" aria-label="Main volume">
      </div>
      <div class="group">
        <label>Accent Volume:</label>
        <input type="range" id="accentVolume" min="0" max="1" step="0.01" value="1" aria-label="Accent volume">
      </div>
      <div class="group">
        <label>Subdivision Tone:</label>
        <select id="subdivisionTone" aria-label="Subdivision beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label>Subdivision Volume:</label>
        <input type="range" id="subdivisionVolume" min="0" max="1" step="0.01" value="0.6" aria-label="Subdivision volume">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Tempo Changes</legend>
      <table id="tempoChangesTable">
        <thead>
          <tr><th>Start Measure</th><th>Type</th><th>New BPM</th><th>New Meter</th><th>Duration</th><th>Action</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="group">
        <label>Start Measure:</label>
        <input type="number" id="changeStart" min="1" value="1" aria-label="Start measure for tempo change">
        <label>Type:</label>
        <select id="changeType" aria-label="Type of tempo change">
          <option value="sudden">Sudden</option>
          <option value="gradual">Gradual</option>
        </select>
        <label>New BPM:</label>
        <input type="number" id="changeBpm" min="1" value="100" aria-label="New tempo in BPM">
        <label>New Meter:</label>
        <select id="changeMeter" aria-label="New time signature">
          <option value=""> (same) </option>
          <option>2/4</option><option>3/4</option><option>4/4</option>
          <option>5/4</option><option>6/8</option><option>7/8</option>
          <option>9/8</option><option>11/8</option><option>13/8</option>
        </select>
        <label>Duration:</label>
        <input type="number" id="changeDuration" min="1" value="1" aria-label="Duration of tempo change">
        <button id="addChange" aria-label="Add tempo change">Add Change</button>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Measure Loop</legend>
      <div class="group">
        <label for="playMeasures">Play Measures:</label>
        <input type="number" id="playMeasures" min="0" value="0" aria-label="Number of measures to play">
        <label for="muteMeasures">Mute Measures:</label>
        <input type="number" id="muteMeasures" min="0" value="0" aria-label="Number of measures to mute">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Measure Pitches</legend>
      <div class="group">
        <label for="measureCount">Measures:</label>
        <input type="number" id="measureCount" min="1" value="1" aria-label="Number of practice measures">
        <label for="humVolume">Hum Volume:</label>
        <input type="range" id="humVolume" min="0" max="1" step="0.01" value="0.3" aria-label="Hum volume">
      </div>
      <div id="measurePitches" class="group"></div>
    </fieldset>

    <!-- New Polyrhythm Section -->
    <fieldset class="section">
      <legend>Polyrhythm</legend>
      <div class="group">
        <label for="polyCount">Crossbeats per measure:</label>
        <input type="number" id="polyCount" min="1" value="3" aria-label="Number of polyrhythm beats">
      </div>
      <div class="group">
        <label for="polyTone">Poly Tone:</label>
        <select id="polyTone" aria-label="Polyrhythm beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label for="polyVolume">Poly Volume:</label>
        <input type="range" id="polyVolume" min="0" max="1" step="0.01" value="1" aria-label="Polyrhythm volume">
      </div>
      <div class="group">
        <label for="polyEnable">Enable:</label>
        <input type="checkbox" id="polyEnable" aria-label="Enable polyrhythm">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Presets</legend>
      <div class="group">
        <input type="text" id="presetName" placeholder="Preset name" aria-label="Preset name">
        <button id="savePreset" aria-label="Save current settings as preset">Save</button>
        <select id="presetList" aria-label="Select preset to load"><option value="">-- Load Preset --</option></select>
        <button id="loadPreset" aria-label="Load selected preset">Load</button>
        <button id="deletePreset" aria-label="Delete selected preset">Delete</button>
      </div>
    </fieldset>
  </div>

  <div id="notation" style="width:420px;height:120px"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const DEBUG = true;

      /* ---------- Audio ---------- */
      let audioCtx, noiseBuf;
      function initAudio() {
        if (audioCtx) return;
        if (!window.AudioContext && !window.webkitAudioContext) {
          console.error('Web Audio API is not supported in this browser');
          return;
        }
        audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        const d = noiseBuf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      }

      /* ---------- UI Refs ---------- */
      const $ = id => document.getElementById(id);
      const bpmInput = $('bpm'),
            subdivisionSel = $('subdivision'),
            tsSel = $('timeSignature');
      const groupingSel = $('grouping'),
            accentCont = $('accentPattern');
      const toneSel = $('tone'),
            accentToneSel = $('accentTone'),
            subToneSel = $('subdivisionTone');
      const volCtrl = $('volume'),
            accentVolCtrl = $('accentVolume'),
            subVolCtrl = $('subdivisionVolume');
      const tapBtn = $('tap'),
            startBtn = $('start'),
            stopBtn = $('stop');
      const tableBody = document.querySelector('#tempoChangesTable tbody');
      const changeStart = $('changeStart'),
            changeType = $('changeType'),
            changeBpm = $('changeBpm'),
            changeMeter = $('changeMeter'),
            changeDur = $('changeDuration'),
            addChangeBtn = $('addChange');
      const playMeasuresInput = $('playMeasures'),
            muteMeasuresInput = $('muteMeasures');
      const measureCountInput = $('measureCount'),
            humVolCtrl = $('humVolume'),
            measurePitchesDiv = $('measurePitches');
      const saveBtn = $('savePreset'),
            loadBtn = $('loadPreset'),
            deleteBtn = $('deletePreset'),
            presetList = $('presetList'),
            presetName = $('presetName');
      const notationDiv = $('notation');
      // Polyrhythm refs
      const polyCountInput = $('polyCount');
      const polyToneSel = $('polyTone');
      const polyVolCtrl = $('polyVolume');
      const polyEnableChk = $('polyEnable');

      /* ---------- Playback State ---------- */
      let timerId, ticks = 0, mainBeats = 0;
      let ticksInMeasure = 0, measureCount = 1;
      let currentBpm = +bpmInput.value,
          currentMeter, currentSubdivision = +subdivisionSel.value;
      let accentBoxes = [], accentToneBoxes = [], taps = [], tempoChanges = [];
      let measurePitchSelects = [];
      let polyAcc = 0;
      let scheduledPolyBeats = [];
      let startTime = 0; // Track start time for drift correction

      // === Notation state ===
      let vfFactory = null;
      let vfContext = null;
      let lastNotationState = null;

      function initNotation() {
        if (vfFactory) return;
        const VF = Vex.Flow;
        vfFactory = new VF.Factory({ 
          renderer: { 
            elementId: 'notation', 
            width: 420, 
            height: 120 
          } 
        });
        vfContext = vfFactory.getContext();
      }

      function clearNotation() {
        if (vfFactory) {
          notationDiv.innerHTML = '';
          vfFactory = null;
          vfContext = null;
        }
      }

      function getNotationState() {
        return {
          meter: currentMeter,
          subdivision: currentSubdivision,
          timeSignature: tsSel.value,
          polyEnabled: polyEnableChk.checked,
          polyCount: +polyCountInput.value
        };
      }

      function hasNotationStateChanged() {
        const newState = getNotationState();
        if (!lastNotationState) return true;
        
        return Object.entries(newState).some(([key, value]) => 
          lastNotationState[key] !== value
        );
      }

      /* ---------- Grouping presets ---------- */
      const groupingOpts = {
        5: [[2,3],[3,2]],
        7: [[2,2,3],[2,3,2],[3,2,2]],
        11: [[3,3,3,2],[3,3,2,3],[3,2,3,3],[2,3,3,3]],
        13: [[3,3,3,2,2],[3,3,2,3,2],[3,2,3,3,2],[2,3,3,3,2]]
      };
      function updateGroupingOpts() {
        const prev = groupingSel.value;
        const num = parseInt(tsSel.value, 10);
        groupingSel.innerHTML = "<option value=''>—Manual—</option>";
        (groupingOpts[num] || []).forEach(g => {
          const opt = document.createElement('option');
          opt.value = g.join(',');
          opt.textContent = g.join(' + ');
          groupingSel.appendChild(opt);
        });
        if (prev && [...groupingSel.options].some(o => o.value === prev))
          groupingSel.value = prev;
      }
      function cloneToneSelect() {
        const sel = document.createElement('select');
        accentToneSel.querySelectorAll('option').forEach(o => {
          const opt = document.createElement('option');
          opt.value = o.value; opt.textContent = o.textContent;
          sel.appendChild(opt);
        });
        sel.value = accentToneSel.value;
        return sel;
      }
      function clonePitchSelect() {
        const sel = document.createElement('select');
        const notes = ['C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4','C5'];
        notes.forEach(n => sel.appendChild(new Option(n, n)));
        return sel;
      }
      function updateAccentPattern() {
        accentCont.innerHTML = ''; accentBoxes = []; accentToneBoxes = [];
        const beats = currentMeter;
        const checks = Array(beats).fill(false);
        if (groupingSel.value) {
          let idx = 0;
          groupingSel.value.split(',').map(Number)
            .forEach(n => { checks[idx] = true; idx += n; });
        } else checks[0] = true;
        checks.forEach((on, i) => {
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = on;
          const toneSel = cloneToneSelect();
          const lbl = document.createElement('label');
          lbl.textContent = i+1;
          lbl.appendChild(cb);
          lbl.appendChild(toneSel);
          accentCont.appendChild(lbl);
          accentBoxes.push(cb); accentToneBoxes.push(toneSel);
        });
      }

      function renderMeasurePitchControls() {
        const count = Math.max(1, parseInt(measureCountInput.value, 10) || 1);
        measurePitchesDiv.innerHTML = '';
        measurePitchSelects = [];
        for (let i = 0; i < count; i++) {
          const lbl = document.createElement('label');
          lbl.textContent = `M${i + 1}`;
          const sel = clonePitchSelect();
          lbl.appendChild(sel);
          measurePitchesDiv.appendChild(lbl);
          measurePitchSelects.push(sel);
        }
      }

      /* ---------- Tempo-change table ---------- */
      function renderTempoChanges() {
        tableBody.innerHTML = '';
        tempoChanges.forEach((r, i) => {
          const tr = document.createElement('tr');
          tr.innerHTML =
            `<td>${r.startMeasure}</td>` +
            `<td>${r.type}</td>` +
            `<td>${Math.round(r.newBpm)}</td>` +
            `<td>${r.newMeter || '—'}</td>` +
            `<td>${r.duration}</td>` +
            `<td><button class='remove-change' data-i='${i}'>✕</button></td>`;
          tableBody.appendChild(tr);
        });
        document.querySelectorAll('.remove-change').forEach(btn => {
          btn.onclick = () => { tempoChanges.splice(+btn.dataset.i, 1); renderTempoChanges(); };
        });
      }
      addChangeBtn.onclick = () => {
        const rule = {
          startMeasure: Math.max(1, parseInt(changeStart.value, 10)),
          type: changeType.value,
          newBpm: Math.max(1, parseInt(changeBpm.value, 10)),
          newMeter: changeMeter.value || null,
          duration: Math.max(1, parseInt(changeDur.value, 10)),
          _inProgress: false, _meterChanged: false, _applied: false
        };
        tempoChanges.push(rule);
        tempoChanges.sort((a, b) => a.startMeasure - b.startMeasure);
        renderTempoChanges();
        if (DEBUG) console.log('Added tempo change', rule);
      };

      /* ---------- VexFlow drawing ---------- */
      function drawNotation(barTick) {
        try {
          // Initialize or reinitialize if state changed
          if (!vfFactory || hasNotationStateChanged()) {
            clearNotation();
            initNotation();
            lastNotationState = getNotationState();
          }

          const VF = Vex.Flow;
          const context = vfContext;
          
          // Clear previous drawing
          context.clear();
          
          const stave = new VF.Stave(10, 40, 400);
          stave.addClef('percussion').addTimeSignature(tsSel.value);
          stave.setContext(context).draw();

          // Map subdivisions to note durations and create groups
          const durMap = {
            1: { duration: 'q', groupSize: 1, perBeat: 1 },    // quarter notes
            2: { duration: '8', groupSize: 2, perBeat: 2 },    // eighth notes
            3: { duration: '8', groupSize: 3, perBeat: 3 },    // triplets
            4: { duration: '16', groupSize: 4, perBeat: 4 },   // sixteenth notes
            5: { duration: '16', groupSize: 5, perBeat: 5 }    // quintuplets
          };
          
          const { duration, groupSize, perBeat } = durMap[currentSubdivision] || durMap[1];
          const beatsInBar = parseInt(tsSel.value);
          const total = beatsInBar * perBeat;
          
          // Create notes with proper styling
          const notes = [];
          const tupletGroups = [];
          
          for (let beat = 0; beat < beatsInBar; beat++) {
            const beatNotes = [];
            for (let i = 0; i < perBeat; i++) {
              const globalIndex = beat * perBeat + i;
              const note = new VF.StaveNote({ 
                keys: ['b/4'], 
                duration: duration + (globalIndex === barTick ? '' : 'r') // Use rests for non-current beats
              });
              
              // Add styling for the current beat
              if (globalIndex === barTick) {
                note.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
              }
              
              // Add dots for compound meters (6/8, 9/8, 12/8)
              if (tsSel.value.endsWith('/8') && duration === 'q') {
                note.addDot(0);
              }
              
              beatNotes.push(note);
              notes.push(note);
            }
            
            // Create tuplets/beams for each beat group
            if (groupSize > 1) {
              if (perBeat === 3) {
                // Create tuplet for triplets
                const tuplet = new VF.Tuplet(beatNotes, {
                  num_notes: 3,
                  notes_occupied: 2
                });
                tupletGroups.push(tuplet);
              } else if (perBeat === 5) {
                // Create tuplet for quintuplets
                const tuplet = new VF.Tuplet(beatNotes, {
                  num_notes: 5,
                  notes_occupied: 4
                });
                tupletGroups.push(tuplet);
              } else if (beatNotes.length > 1) {
                // Create beam for regular groupings
                const beam = new VF.Beam(beatNotes);
                tupletGroups.push(beam);
              }
            }
          }

          // Create voice with proper timing
          let voice;
          if (tsSel.value.endsWith('/8')) {
            // Compound meter (6/8, 9/8, 12/8)
            voice = new VF.Voice({ 
              num_beats: beatsInBar/3, 
              beat_value: 4,
              resolution: VF.RESOLUTION 
            }).addTickables(notes);
          } else {
            // Simple meter
            voice = new VF.Voice({ 
              num_beats: beatsInBar, 
              beat_value: 4,
              resolution: VF.RESOLUTION 
            }).addTickables(notes);
          }

          // Format and draw
          new VF.Formatter()
            .joinVoices([voice])
            .format([voice], 380);
          
          voice.draw(context, stave);
          tupletGroups.forEach(group => group.setContext(context).draw());

          // Draw polyrhythm markers if enabled
          if (polyEnableChk.checked) {
            const num = parseInt(polyCountInput.value, 10);
            crossPositions = [];
            for (let i = 0; i < num; i++) {
              crossPositions.push(Math.round((i * total) / num));
            }
            
            // Add polyrhythm markers using VexFlow annotations
            const markerNotes = notes.filter((_, i) => crossPositions.includes(i));
            markerNotes.forEach(note => {
              note.addModifier(new VF.Annotation('×')
                .setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM)
                .setFont('Arial', 12, 'bold'));
            });
          }
        } catch (err) {
          console.error('Failed to draw notation:', err);
          // Fallback to simpler visualization if VexFlow fails
          clearNotation();
          const div = document.createElement('div');
          div.style.width = '100%';
          div.style.height = '100%';
          div.style.display = 'flex';
          div.style.alignItems = 'center';
          div.style.justifyContent = 'center';
          div.textContent = `Beat ${barTick + 1} of ${currentMeter * currentSubdivision}`;
          notationDiv.appendChild(div);
        }
      }

      /* ---------- Sound helpers ---------- */
      function playWood(vol) {
        initAudio();
        const now = audioCtx.currentTime;
        const src = audioCtx.createBufferSource(); src.buffer = noiseBuf;
        const filt = audioCtx.createBiquadFilter(); filt.type = 'bandpass'; filt.frequency.value = 2000; filt.Q.value = 5;
        const gain = audioCtx.createGain();
        src.connect(filt); filt.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        src.start(now); src.stop(now + 0.05);
      }
      function playKick(vol) {
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
      }
      function playSnare(vol) {
        const now = audioCtx.currentTime;
        const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
        const band = audioCtx.createBiquadFilter(); band.type = 'bandpass'; band.frequency.value = 1000; band.Q.value = 0.7;
        const gain = audioCtx.createGain();
        noise.connect(band); band.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
        noise.start(now); noise.stop(now + 0.2);
      }
      function playHiHat(vol) {
        const now = audioCtx.currentTime;
        const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
        const high = audioCtx.createBiquadFilter(); high.type = 'highpass'; high.frequency.value = 6000;
        const gain = audioCtx.createGain();
        noise.connect(high); high.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        noise.start(now); noise.stop(now + 0.05);
      }
      function oscType(name) { return name === 'click' ? 'square' : name === 'tick' ? 'sine' : 'triangle'; }
      function oscFreq(name) { return name === 'click' ? 1000 : name === 'tick' ? 600 : 1200; }
      function playTone(name, vol) {
        initAudio();
        if (name === 'wood')   return playWood(vol);
        if (name === 'kick')   return playKick(vol);
        if (name === 'snare')  return playSnare(vol);
        if (name === 'hihat')  return playHiHat(vol);
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
        let filt;
        if (name === 'click') {
          filt = audioCtx.createBiquadFilter(); 
          filt.type = 'highpass'; 
          filt.frequency.value = 1500;
          osc.connect(filt); 
          filt.connect(gain);
        } else osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = oscType(name); 
        osc.frequency.setValueAtTime(oscFreq(name), now);
        gain.gain.setValueAtTime(0, now); 
        gain.gain.linearRampToValueAtTime(vol, now + 0.001);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);
        osc.start(now); 
        osc.stop(now + 0.03);
        
        // Clean up nodes
        setTimeout(() => {
          osc.disconnect();
          gain.disconnect();
          if (filt) filt.disconnect();
        }, 50);
      }
      function schedulePolyBeats(barStartTime) {
        if (!polyEnableChk.checked) return;
        const count = parseInt(polyCountInput.value, 10);
        if (count <= 1) return;
        
        // Clear any existing scheduled beats
        const now = audioCtx.currentTime;
        if (now > barStartTime) return; // Don't schedule if we're late
        
        // Clean up previously scheduled beats
        scheduledPolyBeats.forEach(node => {
          try {
            if (node.osc) node.osc.stop();
            if (node.gain) node.gain.disconnect();
            if (node.filt) node.filt.disconnect();
          } catch (err) {
            console.error('Error cleaning up poly beat:', err);
          }
        });
        scheduledPolyBeats = [];
        
        const barDuration = (60 / currentBpm) * currentMeter; // seconds per bar
        for (let i = 1; i < count; i++) {
          const when = barStartTime + (i / count) * barDuration;
          if (when > now) { // Only schedule future beats
            const nodes = playToneAtTime(polyToneSel.value, +polyVolCtrl.value, when);
            if (nodes) scheduledPolyBeats.push(nodes);
          }
        }
      }
      function playToneAtTime(name, vol, when) {
        initAudio();
        const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
        let filt;
        if (name === 'click') {
          filt = audioCtx.createBiquadFilter(); filt.type = 'highpass'; filt.frequency.value = 1500;
          osc.connect(filt); filt.connect(gain);
        } else osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = oscType(name); osc.frequency.setValueAtTime(oscFreq(name), when);
        gain.gain.setValueAtTime(0, when); gain.gain.linearRampToValueAtTime(vol, when + 0.001);
        gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.03);
        osc.start(when); osc.stop(when + 0.03);

        return { osc, gain, filt };
      }

      function noteToFreq(note) {
        const map = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
        const m = note.match(/^([A-G])(#?)(\d)$/);
        if (!m) return 440;
        const [ , l, sharp, oct ] = m;
        const n = (parseInt(oct,10)+1)*12 + map[l] + (sharp ? 1:0);
        return 440 * Math.pow(2, (n-69)/12);
      }

      let currentHum = null;
      function startHum(note) {
        stopHum();
        initAudio();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(noteToFreq(note), audioCtx.currentTime);
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(+humVolCtrl.value, audioCtx.currentTime + 0.05);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start();
        currentHum = {osc, gain};
      }
      function stopHum() {
          if (!currentHum) return;
          const hum = currentHum;
          currentHum = null;
          const now = audioCtx.currentTime;
          try {
            hum.gain.gain.setValueAtTime(hum.gain.gain.value, now);
            hum.gain.gain.linearRampToValueAtTime(0.0001, now + 0.05);
            hum.osc.stop(now + 0.05);
          } catch (e) {
            console.error('Error stopping hum oscillator:', e);
          }
          setTimeout(() => {
            try {
              if (hum.osc) hum.osc.disconnect();
              if (hum.gain) hum.gain.disconnect();
            } catch (err) {
              console.error('Error cleaning up hum nodes:', err);
            }
          }, 100);
        }, 100);
        currentHum = null;
      }

      function isMeasureMuted(num) {
        const playM = +playMeasuresInput.value;
        const muteM = +muteMeasuresInput.value;
        if (playM > 0 && muteM >= 0) {
          const cycleLen = playM + muteM;
          const idx = (num - 1) % cycleLen;
          return idx >= playM;
        }
        return false;
      }
      /* ---------- Scheduler ---------- */
      function doTick() {
        const sub = currentSubdivision;
        const isMain = (ticks % sub === 0);
        if (isMain) {
          mainBeats++;
          // Visual feedback for main beat
          startBtn.classList.remove('beat-flash');
          void startBtn.offsetWidth; // Force reflow
          startBtn.classList.add('beat-flash');
        } else {
          // Visual feedback for subdivision
          startBtn.classList.remove('sub-flash');
          void startBtn.offsetWidth; // Force reflow
          startBtn.classList.add('sub-flash');
        }
        const beatIdx = Math.floor(ticksInMeasure / sub);

        // Drift correction
        const expectedTime = startTime + (ticks * (60 / currentBpm) * 1000 / sub);
        const actualTime = Date.now();
        const drift = actualTime - expectedTime;
        let interval = (60 / currentBpm) * 1000 / sub;
        
        // Adjust interval to correct for drift
        if (Math.abs(drift) > 1) { // Only correct if drift is more than 1ms
          interval = Math.max(0, interval - drift);
        }

        /* ----- measure loop ----- */
        const measureMuted = isMeasureMuted(measureCount);

        /* ----- tempo-changes ----- */
        let tempoChangeApplied = false;
        tempoChanges.forEach(r => {
          if (tempoChangeApplied) return;
          /** Sudden **/
          if (r.type === 'sudden' && !r._applied && isMain && measureCount === r.startMeasure) {
            currentBpm = r.newBpm;
            if (r.newMeter) {
              currentMeter = parseInt(r.newMeter.split('/')[0], 10);
              tsSel.value = r.newMeter;
              updateGroupingOpts(); updateAccentPattern();
            }
            ticksInMeasure = 0;
            r._applied = true;
            tempoChangeApplied = true;
            // Reset timing reference on sudden tempo change
            startTime = Date.now();
            ticks = 0;
            if (DEBUG) console.log('Sudden change applied', { currentBpm, currentMeter });
          }
          /** Gradual **/
          if (r.type === 'gradual' && !tempoChangeApplied) {
            const totalBeats = r.duration * currentMeter;
            const startBeat = (r.startMeasure - 1) * currentMeter;
            if (mainBeats >= startBeat && mainBeats <= startBeat + totalBeats) {
              if (!r._inProgress) { r._inProgress = true; r._initialBpm = currentBpm; }
              const ratio = (mainBeats - startBeat) / totalBeats;
              currentBpm = r._initialBpm + ratio * (r.newBpm - r._initialBpm);
              if (r.newMeter && ratio >= 1 && !r._meterChanged) {
                currentMeter = parseInt(r.newMeter.split('/')[0], 10);
                tsSel.value = r.newMeter;
                updateGroupingOpts(); updateAccentPattern();
                r._meterChanged = true;
                ticksInMeasure = 0;
                tempoChangeApplied = true;
                // Reset timing reference on meter change
                startTime = Date.now();
                ticks = 0;
              }
            }
          }
        });

        /* ----- play sound ----- */
        if (!measureMuted) {
          const accent = accentBoxes[beatIdx]?.checked ?? false;
          const selectedTone = accent ? (accentToneBoxes[beatIdx]?.value || accentToneSel.value) : toneSel.value;
          if (!audioCtx) initAudio();
          if (isMain) {
            playTone(selectedTone, accent ? +accentVolCtrl.value : +volCtrl.value);
          } else {
            playTone(subToneSel.value, +subVolCtrl.value);
          }
        }

        // Polyrhythm
        if (polyEnableChk.checked) {
          for (const pos of crossPositions) {
            if (ticksInMeasure === pos) {
              playTone(polyToneSel.value, +polyVolCtrl.value);
            }
          }
        }

        /* ----- debug log ----- */
        if (DEBUG && isMain) {
          console.log(`Measure ${measureCount}, Beat ${beatIdx + 1}/${currentMeter}, muted=${measureMuted}, drift=${drift}ms`);
        }

        /* ----- update notation & counters ----- */
        drawNotation(ticksInMeasure);
        ticks++; ticksInMeasure++;

        // Reset on new measure
        if (ticksInMeasure >= currentMeter * currentSubdivision) {
          ticksInMeasure = 0;
          measureCount++;
          const now = audioCtx.currentTime;
          schedulePolyBeats(now);
          if (!isMeasureMuted(measureCount)) {
            const pitch = measurePitchSelects[(measureCount - 1) % measurePitchSelects.length]?.value || 'C4';
            startHum(pitch);
          } else {
            stopHum();
          }
        }
        
        timerId = setTimeout(doTick, interval);
      }

      async function startMetronome() {
        try {
          // reset state
          ticks = mainBeats = 0;
          ticksInMeasure = 0; measureCount = 1;
          tempoChanges.forEach(r => { r._inProgress = r._meterChanged = r._applied = false; });
          currentBpm = +bpmInput.value; currentSubdivision = +subdivisionSel.value;
          currentMeter = parseInt(tsSel.value.split('/')[0], 10);
          updateGroupingOpts(); updateAccentPattern(); drawNotation(0);
          initAudio();
          
          // Resume audio context if suspended
          if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
          }
          
          startTime = Date.now(); // Initialize start time
          schedulePolyBeats(audioCtx.currentTime);
          if (!isMeasureMuted(1)) {
            const pitch = measurePitchSelects[0]?.value || 'C4';
            startHum(pitch);
          }
          startBtn.disabled = true; stopBtn.disabled = false;
          doTick();
          if (DEBUG) console.log('Metronome started', { currentBpm, currentMeter, currentSubdivision });
        } catch (err) {
          console.error('Failed to start metronome:', err);
          stopMetronome();
        }
      }
      function stopMetronome() {
        clearTimeout(timerId);
        startBtn.disabled = false; stopBtn.disabled = true;
        
        // Clean up any active audio nodes
        if (audioCtx) {
          // Clean up polyrhythm nodes
          scheduledPolyBeats.forEach(node => {
            try {
              if (node.osc) node.osc.stop();
              if (node.gain) node.gain.disconnect();
              if (node.filt) node.filt.disconnect();
            } catch (err) {
              console.error('Error cleaning up poly beat:', err);
            }
          });
          scheduledPolyBeats = [];
          stopHum();

          audioCtx.close();
          audioCtx = null;
          noiseBuf = null;
        }
        // Clean up notation
        clearNotation();
      }

      /* ---------- Tap tempo ---------- */
      tapBtn.onclick = () => {
        taps.push(Date.now()); if (taps.length > 5) taps.shift();
        if (taps.length > 1) {
          const iv = taps.slice(1).map((t, i) => t - taps[i]);
          bpmInput.value = Math.round(60000 / (iv.reduce((a, b) => a + b) / iv.length));
        }
      };

      /* ---------- Presets ---------- */
      function loadPresets() {
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          presetList.innerHTML = "<option value=''>-- Load Preset --</option>";
          Object.keys(store).forEach(n => presetList.appendChild(new Option(n, n)));
        } catch (err) {
          console.error('Failed to load presets:', err);
          alert('Failed to load presets. Local storage might be corrupted.');
        }
      }
      saveBtn.onclick = () => {
        const name = presetName.value.trim(); 
        if (!name) {
          alert('Please enter a preset name');
          return;
        }
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          if (store[name] && !confirm('A preset with this name already exists. Overwrite?')) {
            return;
          }
          store[name] = {
            bpm: bpmInput.value,
            subdivision: subdivisionSel.value,
            timeSignature: tsSel.value,
            grouping: groupingSel.value,
            tone: toneSel.value,
            volume: volCtrl.value,
            accentTone: accentToneSel.value,
            accentVolume: accentVolCtrl.value,
            subdivisionTone: subToneSel.value,
            subdivisionVolume: subVolCtrl.value,
            tempoChanges,
            playMeasures: +playMeasuresInput.value,
            muteMeasures: +muteMeasuresInput.value,
            measureCount: +measureCountInput.value,
            measurePitches: measurePitchSelects.map(sel => sel.value),
            humVolume: humVolCtrl.value,
            polyCount: +polyCountInput.value,
            polyTone: polyToneSel.value,
            polyVolume: +polyVolCtrl.value,
            polyEnable: polyEnableChk.checked
          };
          localStorage.setItem('metronomePresets', JSON.stringify(store));
          loadPresets();
          presetName.value = '';
        } catch (err) {
          console.error('Failed to save preset:', err);
          alert('Failed to save preset. Storage might be full or corrupted.');
        }
      };
      loadBtn.onclick = () => {
        const name = presetList.value; if (!name) return;
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          const p = store[name];
          if (!p) {
            console.error('Preset not found:', name);
            return;
          }
          
          // Validate and sanitize loaded values
          bpmInput.value = Math.min(Math.max(30, parseInt(p.bpm) || 100), 300);
          subdivisionSel.value = Math.min(Math.max(1, parseInt(p.subdivision) || 1), 5);
          tsSel.value = p.timeSignature || '4/4';
          groupingSel.value = p.grouping || '';
          toneSel.value = p.tone || 'click';
          volCtrl.value = Math.min(Math.max(0, parseFloat(p.volume) || 1), 1);
          accentToneSel.value = p.accentTone || 'click';
          accentVolCtrl.value = Math.min(Math.max(0, parseFloat(p.accentVolume) || 1), 1);
          subToneSel.value = p.subdivisionTone || 'click';
          subVolCtrl.value = Math.min(Math.max(0, parseFloat(p.subdivisionVolume) || 0.6), 1);
          humVolCtrl.value = Math.min(Math.max(0, parseFloat(p.humVolume) || 0.3), 1);
          tempoChanges = Array.isArray(p.tempoChanges) ? p.tempoChanges : [];
          playMeasuresInput.value = Math.max(0, parseInt(p.playMeasures) || 0);
          muteMeasuresInput.value = Math.max(0, parseInt(p.muteMeasures) || 0);

          measureCountInput.value = Math.max(1, parseInt(p.measureCount) || 1);
          renderMeasurePitchControls();
          if (Array.isArray(p.measurePitches)) {
            p.measurePitches.forEach((t, i) => {
              if (measurePitchSelects[i]) measurePitchSelects[i].value = t;
            });
          }

          // Polyrhythm settings
          polyCountInput.value = Math.max(1, parseInt(p.polyCount) || 3);
          polyToneSel.value = p.polyTone || 'click';
          polyVolCtrl.value = Math.min(Math.max(0, parseFloat(p.polyVolume) || 1), 1);
          polyEnableChk.checked = !!p.polyEnable;
          
          updateGroupingOpts(); 
          updateAccentPattern(); 
          renderTempoChanges();
        } catch (err) {
          console.error('Failed to load preset:', err);
        }
      };
      deleteBtn.onclick = () => {
        const name = presetList.value; 
        if (!name) return;
        if (!confirm('Are you sure you want to delete this preset?')) return;
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          delete store[name];
          localStorage.setItem('metronomePresets', JSON.stringify(store));
          loadPresets();
        } catch (err) {
          console.error('Failed to delete preset:', err);
          alert('Failed to delete preset. Storage might be corrupted.');
        }
      };

      /* ---------- Event hooks ---------- */
      startBtn.onclick = startMetronome;
      stopBtn.onclick = stopMetronome;
      
      // Add keyboard shortcuts
      document.addEventListener('keydown', e => {
        // Only handle if not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        
        switch(e.key.toLowerCase()) {
          case ' ':  // Space bar
            e.preventDefault();
            if (!startBtn.disabled) startMetronome();
            else if (!stopBtn.disabled) stopMetronome();
            break;
          case 't':  // Tap tempo
            e.preventDefault();
            tapBtn.click();
            break;
          case 'arrowup':  // Increase BPM
            e.preventDefault();
            bpmInput.value = Math.min(300, +bpmInput.value + (e.shiftKey ? 10 : 1));
            if (!startBtn.disabled) currentBpm = +bpmInput.value;
            break;
          case 'arrowdown':  // Decrease BPM
            e.preventDefault();
            bpmInput.value = Math.max(30, +bpmInput.value - (e.shiftKey ? 10 : 1));
            if (!startBtn.disabled) currentBpm = +bpmInput.value;
            break;
          case 'escape':  // Stop
            e.preventDefault();
            if (!stopBtn.disabled) stopMetronome();
            break;
        }
      });
      
      // Add input validation
      bpmInput.onchange = () => {
        const val = +bpmInput.value;
        bpmInput.value = Math.min(Math.max(30, val), 300);
      };
      
      playMeasuresInput.onchange = () => {
        const val = +playMeasuresInput.value;
        playMeasuresInput.value = Math.max(0, val);
      };
      
      muteMeasuresInput.onchange = () => {
        const val = +muteMeasuresInput.value;
        muteMeasuresInput.value = Math.max(0, val);
      };
      
      polyCountInput.onchange = () => {
        const val = +polyCountInput.value;
        polyCountInput.value = Math.min(Math.max(1, val), 16);
      };
      
      changeStart.onchange = () => {
        const val = +changeStart.value;
        changeStart.value = Math.max(1, val);
      };
      
      changeBpm.onchange = () => {
        const val = +changeBpm.value;
        changeBpm.value = Math.min(Math.max(30, val), 300);
      };
      
      changeDur.onchange = () => {
        const val = +changeDur.value;
        changeDur.value = Math.max(1, val);
      };

      tsSel.onchange = () => {
        currentMeter = parseInt(tsSel.value.split('/')[0], 10);
        updateGroupingOpts(); updateAccentPattern(); drawNotation(0);
      };
      
      subdivisionSel.onchange = () => {
        currentSubdivision = +subdivisionSel.value; drawNotation(0);
      };
      
      groupingSel.onchange = updateAccentPattern;

      measureCountInput.onchange = () => {
        const val = +measureCountInput.value;
        measureCountInput.value = Math.max(1, val);
        renderMeasurePitchControls();
      };

      /* ---------- Init ---------- */
      initAudio();
      loadPresets();
      renderMeasurePitchControls();
      tsSel.dispatchEvent(new Event('change'));
    });
  </script>
</body>
</html>
