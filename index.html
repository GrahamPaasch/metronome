<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Browser Metronome</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <meta name="theme-color" content="#4CAF50">
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <style>
    :root {
      --bg-primary: #f0f2f5;
      --bg-secondary: #fff;
      --bg-tertiary: #fafafa;
      --bg-input: #fafafa;
      --text-primary: #333;
      --text-secondary: #666;
      --text-muted: #999;
      --border-color: #ccc;
      --border-light: #ddd;
      --shadow-color: rgba(0,0,0,0.1);
      --accent-color: #4CAF50;
      --accent-hover: #45A049;
      --accent-secondary: #2196F3;
      --danger-color: #e74c3c;
      --visualizer-bg: linear-gradient(to bottom, #f8f9fa 0%, #e9ecef 100%);
    }
    
    body.dark-mode {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --bg-input: #1a1a2e;
      --text-primary: #e8e8e8;
      --text-secondary: #aaa;
      --text-muted: #777;
      --border-color: #333;
      --border-light: #2a2a4a;
      --shadow-color: rgba(0,0,0,0.3);
      --visualizer-bg: linear-gradient(to bottom, #16213e 0%, #0f3460 100%);
    }
    
    body {
      font-family: sans-serif;
      margin: 0; padding: 2rem;
      background: var(--bg-primary); 
      color: var(--text-primary);
      display: flex; flex-direction: column; align-items: center;
      transition: background 0.3s ease, color 0.3s ease;
    }
    h1 { margin-bottom: 1.5rem; }
    .controls {
      width: 100%; max-width: 700px;
      display: flex; flex-direction: column; gap: 1.5rem;
    }
    fieldset.section {
      background: var(--bg-secondary); 
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 6px var(--shadow-color);
      transition: background 0.3s ease;
      padding: 1rem;
    }
    legend { font-weight: bold; padding: 0 0.5rem; }
    .group {
      display: flex; flex-wrap: wrap; gap: 1rem;
      align-items: center; margin-top: 0.5rem;
    }
    .group label,
    .group button,
    .group select,
    .group input[type='number'],
    .group input[type='range'],
    .group input[type='checkbox'] {
      font-size: 1rem; padding: 0.5rem;
      border: 1px solid var(--border-color); 
      border-radius: 4px;
      background: var(--bg-input);
      color: var(--text-primary);
      transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    .group select option {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    .group input[type='checkbox'] { width: auto; }
    #start { background: var(--accent-color); color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; }
    #start:hover { background: var(--accent-hover); }
    #addChange { background: var(--accent-color); color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; }
    #addChange:hover { background: var(--accent-hover); }
    #focusModeBtn { background: var(--accent-secondary); color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; border-radius:4px; }
    #focusModeBtn:hover { background: #1976D2; }
    #darkModeBtn { background: #333; color:#fff; border:none; cursor:pointer; padding:0.5rem 1rem; border-radius:4px; }
    body.dark-mode #darkModeBtn { background: #FFD700; color: #333; }
    #darkModeBtn:hover { opacity: 0.9; }
    #notation { margin-top:2rem; border:1px solid var(--border-color); background: var(--bg-secondary); }
    table { width:100%; border-collapse:collapse; margin-top:0.5rem; }
    th,td { border:1px solid var(--border-light); padding:0.5rem; text-align:center; }
    th { background: var(--bg-tertiary); }
    .remove-change { background: var(--danger-color); color:#fff; border:none; padding:0.25rem 0.5rem; cursor:pointer; }
    .remove-change:hover { background:#c0392b; }
    #accentPattern label { display:inline-flex; align-items:center; margin-right:0.5rem; }
    #accentPattern select { margin-left:0.25rem; }
    .beat-flash { animation: flash 0.1s ease-out; }
    .sub-flash { animation: subFlash 0.1s ease-out; }
    body.hc .beat-flash { animation: flashHC 0.1s ease-out; }
    body.hc .sub-flash { animation: subFlashHC 0.1s ease-out; }
    @keyframes flash {
      0% { background: #4CAF50; }
      100% { background: none; }
    }
    @keyframes subFlash {
      0% { background: #90CAF9; }
      100% { background: none; }
    }
    @keyframes flashHC {
      0% { background: #000; color: #fff; }
      100% { background: none; color: inherit; }
    }
    @keyframes subFlashHC {
      0% { background: #0000FF; color: #fff; }
      100% { background: none; color: inherit; }
    }

    /* Rhythm Builder Styles */
    .rhythm-builder {
      margin-top: 1rem;
    }
    .rhythm-builder .rb-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .rhythm-builder .rb-group {
      display: flex;
      gap: 0.25rem;
      padding: 0.25rem;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }
    .rhythm-builder .rb-group-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      margin-bottom: 0.25rem;
      display: block;
    }
    .rhythm-builder button {
      min-width: 36px;
      height: 36px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.15s ease;
    }
    .rhythm-builder button:hover {
      background: #e8f5e9;
      border-color: var(--accent-color);
    }
    body.dark-mode .rhythm-builder button:hover {
      background: #1a3a1a;
    }
    .rhythm-builder button.active {
      background: var(--accent-color);
      color: #fff;
      border-color: #388E3C;
    }
    .rhythm-builder button.modifier {
      font-size: 0.9rem;
      min-width: 50px;
    }
    .rhythm-builder button.action {
      background: var(--accent-secondary);
      color: #fff;
      border-color: #1976D2;
      padding: 0.5rem 1rem;
    }
    .rhythm-builder button.action:hover {
      background: #1976D2;
    }
    .rhythm-builder button.danger {
      background: var(--danger-color);
      color: #fff;
      border-color: #d32f2f;
    }
    .rhythm-builder button.danger:hover {
      background: #d32f2f;
    }
    .rhythm-builder .rb-display {
      min-height: 120px;
      background: var(--bg-secondary);
      border: 2px solid var(--border-light);
      border-radius: 8px;
      margin: 1rem 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .rhythm-builder .rb-pattern-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.5rem;
      min-height: 40px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      margin-bottom: 1rem;
    }
    .rhythm-builder .rb-pattern-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      background: #e3f2fd;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .rhythm-builder .rb-pattern-item.rest {
      background: #f3e5f5;
    }
    .rhythm-builder .rb-pattern-item.tuplet {
      background: #fff3e0;
    }
    .rhythm-builder .rb-pattern-item .remove {
      cursor: pointer;
      color: #999;
      font-size: 0.8rem;
    }
    .rhythm-builder .rb-pattern-item .remove:hover {
      color: #f44336;
    }
    .rhythm-builder .rb-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    /* Tap-to-rhythm */
    .rhythm-builder .rb-tap-section {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      text-align: center;
    }
    .rhythm-builder .rb-tap-btn {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(145deg, var(--accent-color), #2E7D32);
      color: #fff;
      font-size: 1.2rem;
      font-weight: bold;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      transition: all 0.1s ease;
      user-select: none;
    }
    .rhythm-builder .rb-tap-btn:active,
    .rhythm-builder .rb-tap-btn.tapping {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
    }
    .rhythm-builder .rb-tap-btn.recording {
      background: linear-gradient(145deg, #f44336, #c62828);
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      from { box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4); }
      to { box-shadow: 0 4px 25px rgba(244, 67, 54, 0.7); }
    }
    .rhythm-builder .rb-tap-info {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    .rhythm-builder .rb-tap-controls {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      margin-top: 1rem;
    }
    
    .rhythm-builder .rb-library {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-light);
    }
    .rhythm-builder .rb-library select {
      min-width: 200px;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: var(--bg-input);
      color: var(--text-primary);
    }
    .rhythm-builder .rb-library-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .rhythm-builder .rb-library-item {
      padding: 0.5rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .rhythm-builder .rb-library-item:hover {
      background: #e8f5e9;
      border-color: var(--accent-color);
    }
    body.dark-mode .rhythm-builder .rb-library-item:hover {
      background: #1a3a1a;
    }
    .rhythm-builder .rb-library-item .name {
      font-weight: bold;
      font-size: 0.9rem;
    }
    .rhythm-builder .rb-library-item .desc {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    .rhythm-builder .rb-library-item .difficulty {
      font-size: 0.7rem;
      color: var(--accent-color);
    }

    /* Beat Visualizations */
    .beat-visualizer {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      height: 200px;
      margin: 1rem 0;
      background: var(--visualizer-bg);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      transition: background 0.3s ease;
    }
    .beat-visualizer.hidden {
      display: none;
    }
    
    /* Bouncing Ball */
    .bouncing-ball-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      justify-content: center;
    }
    .bouncing-ball {
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, var(--accent-color), #2E7D32);
      border-radius: 50%;
      position: absolute;
      bottom: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: transform 0.05s ease-out;
    }
    .bouncing-ball.accent {
      background: radial-gradient(circle at 30% 30%, #FF5722, #D84315);
    }
    .bouncing-ball-shadow {
      width: 50px;
      height: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 50%;
      position: absolute;
      bottom: 5px;
      filter: blur(3px);
    }
    
    /* Beat position markers */
    .beat-markers {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30px;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 0 20px;
    }
    .beat-marker {
      width: 12px;
      height: 12px;
      background: var(--text-muted);
      border-radius: 50%;
      transition: all 0.1s ease;
    }
    .beat-marker.active {
      background: var(--accent-color);
      transform: scale(1.3);
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }
    .beat-marker.accent-marker {
      width: 16px;
      height: 16px;
      border: 2px solid #FF5722;
    }
    .beat-marker.accent-marker.active {
      background: #FF5722;
      box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
    }

    /* Pendulum */
    .pendulum-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      justify-content: center;
    }
    .pendulum-pivot {
      position: absolute;
      top: 0;
      width: 20px;
      height: 20px;
      background: #333;
      border-radius: 50%;
      z-index: 2;
    }
    .pendulum-arm {
      position: absolute;
      top: 10px;
      width: 4px;
      height: 140px;
      background: linear-gradient(to bottom, #333, #666);
      transform-origin: top center;
      border-radius: 2px;
    }
    .pendulum-weight {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 40px;
      background: radial-gradient(circle at 30% 30%, #FFD700, #B8860B);
      border-radius: 50%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    .pendulum-tick-left,
    .pendulum-tick-right {
      position: absolute;
      bottom: 20px;
      width: 3px;
      height: 20px;
      background: #999;
    }
    .pendulum-tick-left { left: 30%; transform: rotate(-30deg); }
    .pendulum-tick-right { right: 30%; transform: rotate(30deg); }

    /* Fullscreen Focus Mode */
    .focus-mode {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a2e;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    .focus-mode .focus-visualizer {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 800px;
    }
    .focus-mode .bouncing-ball-container,
    .focus-mode .pendulum-container {
      width: 100%;
      height: 400px;
    }
    .focus-mode .bouncing-ball {
      width: 80px;
      height: 80px;
    }
    .focus-mode .bouncing-ball-shadow {
      width: 80px;
      height: 16px;
    }
    .focus-mode .beat-markers {
      height: 50px;
    }
    .focus-mode .beat-marker {
      width: 20px;
      height: 20px;
    }
    .focus-mode .beat-marker.accent-marker {
      width: 26px;
      height: 26px;
    }
    .focus-mode .pendulum-arm {
      height: 250px;
    }
    .focus-mode .pendulum-weight {
      width: 60px;
      height: 60px;
    }
    .focus-mode .pendulum-pivot {
      width: 30px;
      height: 30px;
    }
    .focus-mode .focus-info {
      color: #fff;
      text-align: center;
      margin-top: 2rem;
    }
    .focus-mode .focus-bpm {
      font-size: 5rem;
      font-weight: bold;
      color: #4CAF50;
      line-height: 1;
    }
    .focus-mode .focus-meter {
      font-size: 2rem;
      color: #888;
      margin-top: 0.5rem;
    }
    .focus-mode .focus-beat-counter {
      font-size: 8rem;
      font-weight: bold;
      color: #fff;
      opacity: 0.9;
      margin: 1rem 0;
      min-width: 150px;
    }
    .focus-mode .focus-controls {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }
    .focus-mode .focus-controls button {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .focus-mode .focus-exit {
      background: #333;
      color: #fff;
    }
    .focus-mode .focus-exit:hover {
      background: #444;
    }
    .focus-mode .focus-playpause {
      background: #4CAF50;
      color: #fff;
      min-width: 120px;
    }
    .focus-mode .focus-playpause:hover {
      background: #45A049;
    }
    .focus-mode .focus-bpm-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .focus-mode .focus-bpm-btn {
      width: 50px;
      height: 50px;
      font-size: 1.5rem;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }
    .focus-mode .focus-bpm-btn:hover {
      background: #4CAF50;
    }
  </style>
</head>
<body>
  <h1>Browser Metronome</h1>
  <div class="controls">
    <fieldset class="section">
      <legend>Tempo</legend>
      <div class="group">
        <label for="bpm">BPM:</label>
        <input type="number" id="bpm" value="100" min="30" max="300">
        <button id="tap" aria-label="Tap to set tempo">Tap Tempo</button>
        <button id="start" aria-label="Start metronome">Start</button>
        <button id="stop" disabled aria-label="Stop metronome">Stop</button>
      </div>
      <div class="group">
        <label for="countIn">Count-in:</label>
        <select id="countIn" aria-label="Count-in beats">
          <option value="0">None</option>
          <option value="1">1 beat</option>
          <option value="2">2 beats</option>
          <option value="4" selected>1 bar</option>
          <option value="8">2 bars</option>
        </select>
        <label for="countInTone">Count-in tone:</label>
        <select id="countInTone" aria-label="Count-in sound">
          <option value="click">Click</option>
          <option value="stick" selected>Stick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
        </select>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Meter &amp; Subdivision</legend>
      <div class="group">
        <label for="timeSignature">Time Signature:</label>
        <select id="timeSignature" aria-label="Time signature">
          <option>2/4</option><option>3/4</option><option selected>4/4</option>
          <option>5/4</option><option>8/4</option><option>6/8</option><option>7/8</option>
          <option>9/8</option><option>11/8</option><option>12/8</option><option>13/8</option>
          <option>16/16</option>
        </select>
        <label for="subdivision">Subdivision:</label>
        <select id="subdivision" aria-label="Beat subdivision">
          <option value="1">None</option>
          <option value="2">8th</option>
          <option value="3">Triplet</option>
          <option value="4">16th</option>
          <option value="5">Quintuplet</option>
        </select>
      </div>
      <div class="group">
        <label for="swingType">Swing:</label>
        <select id="swingType" aria-label="Swing type">
          <option value="off" selected>Off</option>
          <option value="8">8ths</option>
          <option value="16">16ths</option>
        </select>
        <label for="swingAmount">Amount:</label>
        <input type="range" id="swingAmount" min="0" max="1" step="0.01" value="0" aria-label="Swing amount">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Accent Grouping</legend>
      <div class="group">
        <label>Grouping Pattern:</label>
        <select id="grouping" aria-label="Accent grouping pattern"><option value="">‚ÄîManual‚Äî</option></select>
        <div id="accentPattern"></div>
      </div>
      <div class="group">
        <label for="retainAccents">Retain accents on meter change</label>
        <input type="checkbox" id="retainAccents" aria-label="Retain accents on meter change">
      </div>
      <div class="group">
        <label>Default Accent Tone:</label>
        <select id="accentTone" aria-label="Default accent sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Tones &amp; Levels</legend>
      <div class="group">
        <label>Main Tone:</label>
        <select id="tone" aria-label="Main beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label>Main Volume:</label>
        <input type="range" id="volume" min="0" max="1" step="0.01" value="1" aria-label="Main volume">
      </div>
      <div class="group">
        <label>Accent Volume:</label>
        <input type="range" id="accentVolume" min="0" max="1" step="0.01" value="1" aria-label="Accent volume">
      </div>
      <div class="group">
        <label>Subdivision Tone:</label>
        <select id="subdivisionTone" aria-label="Subdivision beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label>Subdivision Volume:</label>
        <input type="range" id="subdivisionVolume" min="0" max="1" step="0.01" value="0.6" aria-label="Subdivision volume">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Tempo Changes</legend>
      <table id="tempoChangesTable">
        <thead>
          <tr><th>Start Measure</th><th>Type</th><th>New BPM</th><th>New Meter</th><th>Duration</th><th>Action</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="group">
        <label>Start Measure:</label>
        <input type="number" id="changeStart" min="1" value="1" aria-label="Start measure for tempo change">
        <label>Type:</label>
        <select id="changeType" aria-label="Type of tempo change">
          <option value="sudden">Sudden</option>
          <option value="gradual">Gradual</option>
        </select>
        <label>New BPM:</label>
        <input type="number" id="changeBpm" min="1" value="100" aria-label="New tempo in BPM">
        <label>New Meter:</label>
        <select id="changeMeter" aria-label="New time signature">
          <option value=""> (same) </option>
          <option>2/4</option><option>3/4</option><option>4/4</option>
          <option>5/4</option><option>6/8</option><option>7/8</option>
          <option>9/8</option><option>11/8</option><option>13/8</option>
        </select>
        <label>Duration:</label>
        <input type="number" id="changeDuration" min="1" value="1" aria-label="Duration of tempo change">
        <button id="addChange" aria-label="Add tempo change">Add Change</button>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Measure Loop</legend>
      <div class="group">
        <label for="playMeasures">Play Measures:</label>
        <input type="number" id="playMeasures" min="0" value="0" aria-label="Number of measures to play">
        <label for="muteMeasures">Mute Measures:</label>
        <input type="number" id="muteMeasures" min="0" value="0" aria-label="Number of measures to mute">
        <label for="checkpointBeep">Checkpoint beep on unmute</label>
        <input type="checkbox" id="checkpointBeep" checked aria-label="Checkpoint beep on unmute">
      </div>
      <div class="group">
        <label for="drillEnable">Subdivision Drill:</label>
        <input type="checkbox" id="drillEnable" aria-label="Enable subdivision drill">
        <label for="drillMeasures">Measures per step:</label>
        <input type="number" id="drillMeasures" min="1" value="2" aria-label="Measures per drill step">
        <span>(cycles 1‚Üí2‚Üí3‚Üí4)</span>
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Measure Pitches</legend>
      <div class="group">
        <label for="measureCount">Measures:</label>
        <input type="number" id="measureCount" min="1" value="1" aria-label="Number of practice measures">
        <label for="humVolume">Hum Volume:</label>
        <input type="range" id="humVolume" min="0" max="1" step="0.01" value="0" aria-label="Hum volume">
      </div>
      <div id="measurePitches" class="group"></div>
    </fieldset>

    <fieldset class="section">
      <legend>Display</legend>
      <div class="group">
        <label for="visualType">Visualization:</label>
        <select id="visualType" aria-label="Beat visualization type">
          <option value="none">None</option>
          <option value="ball" selected>Bouncing Ball</option>
          <option value="pendulum">Pendulum</option>
        </select>
        <label for="highContrast">High Contrast Visuals</label>
        <input type="checkbox" id="highContrast" aria-label="High contrast visuals">
        <button id="darkModeBtn" type="button" aria-label="Toggle dark mode">üåô Dark</button>
        <button id="focusModeBtn" type="button" aria-label="Enter focus mode">üéØ Focus Mode</button>
      </div>
    </fieldset>

    <!-- Beat Visualizer -->
    <div class="beat-visualizer" id="beatVisualizer">
      <!-- Bouncing Ball Mode -->
      <div class="bouncing-ball-container" id="ballContainer">
        <div class="bouncing-ball-shadow" id="ballShadow"></div>
        <div class="bouncing-ball" id="bouncingBall"></div>
        <div class="beat-markers" id="beatMarkers"></div>
      </div>
      <!-- Pendulum Mode -->
      <div class="pendulum-container" id="pendulumContainer" style="display:none;">
        <div class="pendulum-tick-left"></div>
        <div class="pendulum-tick-right"></div>
        <div class="pendulum-pivot"></div>
        <div class="pendulum-arm" id="pendulumArm">
          <div class="pendulum-weight"></div>
        </div>
      </div>
    </div>

    <!-- New Polyrhythm Section -->
    <fieldset class="section">
      <legend>Polyrhythm</legend>
      <div class="group">
        <label for="polyCount">Crossbeats per measure:</label>
        <input type="number" id="polyCount" min="1" value="3" aria-label="Number of polyrhythm beats">
      </div>
      <div class="group">
        <label for="polyTone">Poly Tone:</label>
        <select id="polyTone" aria-label="Polyrhythm beat sound">
          <option value="click">Click</option>
          <option value="tick">Tick</option>
          <option value="bell">Bell</option>
          <option value="wood">Woodblock</option>
          <option value="kick">Kick</option>
          <option value="snare">Snare</option>
          <option value="hihat">Hihat</option>
        </select>
        <label for="polyVolume">Poly Volume:</label>
        <input type="range" id="polyVolume" min="0" max="1" step="0.01" value="1" aria-label="Polyrhythm volume">
      </div>
      <div class="group">
        <label for="polyEnable">Enable:</label>
        <input type="checkbox" id="polyEnable" aria-label="Enable polyrhythm">
      </div>
    </fieldset>

    <fieldset class="section">
      <legend>Presets</legend>
      <div class="group">
        <input type="text" id="presetName" placeholder="Preset name" aria-label="Preset name">
        <button id="savePreset" aria-label="Save current settings as preset">Save</button>
        <select id="presetList" aria-label="Select preset to load"><option value="">-- Load Preset --</option></select>
        <button id="loadPreset" aria-label="Load selected preset">Load</button>
        <button id="deletePreset" aria-label="Delete selected preset">Delete</button>
      </div>
    </fieldset>

    <!-- Rhythm Builder Section -->
    <fieldset class="section rhythm-builder" id="rhythmBuilderSection">
      <legend>Rhythm Builder</legend>
      
      <!-- Note/Rest Toolbar -->
      <div class="rb-toolbar">
        <div>
          <span class="rb-group-label">Notes</span>
          <div class="rb-group" id="rbNotes">
            <button data-note="w" title="Whole note">ùÖù</button>
            <button data-note="h" title="Half note">ùÖóùÖ•</button>
            <button data-note="q" title="Quarter note">‚ô©</button>
            <button data-note="e" title="Eighth note">‚ô™</button>
            <button data-note="s" title="Sixteenth note">ùÖòùÖ•ùÖØ</button>
          </div>
        </div>
        <div>
          <span class="rb-group-label">Rests</span>
          <div class="rb-group" id="rbRests">
            <button data-rest="w" title="Whole rest">ùÑª</button>
            <button data-rest="h" title="Half rest">ùÑº</button>
            <button data-rest="q" title="Quarter rest">ùÑΩ</button>
            <button data-rest="e" title="Eighth rest">ùÑæ</button>
            <button data-rest="s" title="Sixteenth rest">ùÑø</button>
          </div>
        </div>
        <div>
          <span class="rb-group-label">Modifiers</span>
          <div class="rb-group" id="rbModifiers">
            <button id="rbDot" class="modifier" title="Dotted (1.5x duration)">Dot</button>
            <button id="rbTriplet" class="modifier" title="Triplet (3 in space of 2)">Trip</button>
            <button id="rbQuint" class="modifier" title="Quintuplet (5 in space of 4)">Quint</button>
          </div>
        </div>
        <div>
          <span class="rb-group-label">Actions</span>
          <div class="rb-group">
            <button id="rbUndo" class="action" title="Remove last note">‚Ü© Undo</button>
            <button id="rbClear" class="danger" title="Clear all">Clear</button>
          </div>
        </div>
      </div>

      <!-- Pattern display -->
      <div class="rb-pattern-list" id="rbPatternList">
        <span style="color:#999; font-size:0.9rem;">Click notes above to build your rhythm...</span>
      </div>

      <!-- VexFlow rendering -->
      <div class="rb-display" id="rbDisplay"></div>

      <!-- Controls -->
      <div class="rb-controls">
        <button id="rbPlay" class="action" title="Play pattern">‚ñ∂ Play</button>
        <button id="rbStop" class="action" title="Stop playback">‚èπ Stop</button>
        <label>
          <input type="checkbox" id="rbLoop"> Loop
        </label>
        <label>
          BPM: <input type="number" id="rbBpm" value="100" min="30" max="300" style="width:60px">
        </label>
        <label>
          Volume: <input type="range" id="rbVolume" min="0" max="1" step="0.01" value="0.8">
        </label>
      </div>

      <!-- Tap to Rhythm -->
      <div class="rb-tap-section">
        <button class="rb-tap-btn" id="rbTapBtn">TAP<br>RHYTHM</button>
        <div class="rb-tap-info" id="rbTapInfo">Tap the button to record a rhythm pattern</div>
        <div class="rb-tap-controls">
          <button id="rbTapStart" class="action">üé§ Start Recording</button>
          <button id="rbTapStop" class="action" disabled>‚èπ Stop</button>
          <button id="rbTapApply" class="action" disabled>‚úì Apply</button>
        </div>
        <div class="group" style="justify-content:center; margin-top:0.5rem;">
          <label>Quantize: 
            <select id="rbTapQuantize">
              <option value="0">Off</option>
              <option value="4" selected>Quarter</option>
              <option value="8">Eighth</option>
              <option value="16">Sixteenth</option>
            </select>
          </label>
          <label>Reference BPM: <input type="number" id="rbTapBpm" value="100" min="30" max="300" style="width:60px"></label>
        </div>
      </div>

      <!-- Pattern Library -->
      <div class="rb-library">
        <div class="group">
          <label>Load from Library:</label>
          <select id="rbLibraryCategory">
            <option value="">-- Select Category --</option>
            <option value="basic">Basic Rhythms</option>
            <option value="dotted">Dotted Rhythms</option>
            <option value="syncopation">Syncopation</option>
            <option value="triplets">Triplets</option>
            <option value="compound">Compound Meter (6/8)</option>
            <option value="oddMeter">Odd Meters</option>
            <option value="latin">Latin Rhythms</option>
            <option value="polyrhythm">Polyrhythms</option>
          </select>
        </div>
        <div class="rb-library-grid" id="rbLibraryGrid"></div>
      </div>
    </fieldset>
  </div>

  <div id="notation" style="width:420px;height:120px"></div>

  <fieldset class="section" style="width:100%; max-width:700px; margin-top:1rem;">
    <legend>Session</legend>
    <div class="group">
      <label>Beats:</label>
      <span id="sessionBeats">0</span>
      <label>Measures:</label>
      <span id="sessionMeasures">0</span>
      <label>Time:</label>
      <span id="sessionTime">00:00</span>
      <label>Avg BPM:</label>
      <span id="sessionAvgBpm">0</span>
    </div>
  </fieldset>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const DEBUG = true;

      /* ---------- Audio ---------- */
      let audioCtx, noiseBuf;
      function initAudio() {
        // Lazily create the AudioContext on demand (user gesture)
        if (audioCtx) return;
        if (!window.AudioContext && !window.webkitAudioContext) {
          console.error('Web Audio API is not supported in this browser');
          return;
        }
        audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        // Track state changes so we can try to auto-recover
        audioCtx.onstatechange = async () => {
          if (DEBUG) console.log('AudioContext state:', audioCtx?.state);
          if (!audioCtx) return;
          if (audioCtx.state === 'suspended') {
            try { await audioCtx.resume(); } catch {}
          } else if (audioCtx.state === 'closed') {
            // Mark for reinit on next use
            audioCtx = null;
            noiseBuf = null;
          }
        };
        noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        const d = noiseBuf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      }

      // One-time unlock on first user gesture (helps Safari/iOS)
      const unlockOnce = async () => {
        initAudio();
        try { await ensureAudio(); } catch {}
        // Tiny silent tick to fully unlock audio pipeline on iOS
        try {
          if (audioCtx && audioCtx.state === 'running') {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            g.gain.value = 0.0001;
            osc.connect(g).connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 0.005);
          }
        } catch {}
        ['pointerdown','touchstart','keydown','mousedown'].forEach(evt =>
          window.removeEventListener(evt, unlockOnce, { capture: true })
        );
      };
      ['pointerdown','touchstart','keydown','mousedown'].forEach(evt =>
        window.addEventListener(evt, unlockOnce, { capture: true, once: true })
      );

      // Ensure audio is ready and resumed; call from user-driven events and playback helpers
      async function ensureAudio() {
        if (!audioCtx) initAudio();
        if (audioCtx && audioCtx.state === 'suspended') {
          try { await audioCtx.resume(); } catch (e) { console.error('Failed to resume audio context', e); }
        }
      }

      // Recreate audio context if output devices change (e.g., BT profile switch)
      async function recreateAudio() {
        try { if (audioCtx) await audioCtx.close(); } catch {}
        audioCtx = null;
        noiseBuf = null;
        initAudio();
        // Best-effort resume; if blocked, next user gesture will unlock
        try { await ensureAudio(); } catch {}
      }

      /* ---------- UI Refs ---------- */
      const $ = id => document.getElementById(id);
      const bpmInput = $('bpm'),
            subdivisionSel = $('subdivision'),
            tsSel = $('timeSignature');
      const groupingSel = $('grouping'),
            accentCont = $('accentPattern');
      const toneSel = $('tone'),
            accentToneSel = $('accentTone'),
            subToneSel = $('subdivisionTone');
      const volCtrl = $('volume'),
            accentVolCtrl = $('accentVolume'),
            subVolCtrl = $('subdivisionVolume');
      const swingTypeSel = $('swingType'),
            swingAmtCtrl = $('swingAmount');
      const tapBtn = $('tap'),
            startBtn = $('start'),
            stopBtn = $('stop'),
            countInSel = $('countIn');
      const tableBody = document.querySelector('#tempoChangesTable tbody');
      const changeStart = $('changeStart'),
            changeType = $('changeType'),
            changeBpm = $('changeBpm'),
            changeMeter = $('changeMeter'),
            changeDur = $('changeDuration'),
            addChangeBtn = $('addChange');
      const playMeasuresInput = $('playMeasures'),
            muteMeasuresInput = $('muteMeasures');
      const retainAccentsChk = $('retainAccents');
      const checkpointBeepChk = $('checkpointBeep');
      const drillEnableChk = $('drillEnable'),
            drillMeasuresInput = $('drillMeasures');
      const measureCountInput = $('measureCount'),
            humVolCtrl = $('humVolume'),
            measurePitchesDiv = $('measurePitches');
      const saveBtn = $('savePreset'),
            loadBtn = $('loadPreset'),
            deleteBtn = $('deletePreset'),
            presetList = $('presetList'),
            presetName = $('presetName');
      const notationDiv = $('notation');
      const highContrastChk = $('highContrast');
      // Polyrhythm refs
      const polyCountInput = $('polyCount');
      const polyToneSel = $('polyTone');
      const polyVolCtrl = $('polyVolume');
      const polyEnableChk = $('polyEnable');

      // Visualization refs
      const visualTypeSel = $('visualType');
      const beatVisualizer = $('beatVisualizer');
      const ballContainer = $('ballContainer');
      const bouncingBall = $('bouncingBall');
      const ballShadow = $('ballShadow');
      const beatMarkersDiv = $('beatMarkers');
      const pendulumContainer = $('pendulumContainer');
      const pendulumArm = $('pendulumArm');

      /* ---------- Playback State ---------- */
      let timerId, ticks = 0, mainBeats = 0;
      let ticksInMeasure = 0, measureCount = 1;
      let currentBpm = +bpmInput.value,
          currentMeter, currentSubdivision = +subdivisionSel.value;
      let accentBoxes = [], accentToneBoxes = [], taps = [], tempoChanges = [];
      let measurePitchSelects = [];
      let polyAcc = 0;
      let scheduledPolyBeats = [];
      let startTime = 0; // Track start time for drift correction
      let nextClickTimeSec = 0; // AudioContext currentTime for next scheduled click

      // Drill state
      const drillCycle = [1,2,3,4];
      let drillIndex = 0;
      let drillMeasureCounter = 0;

      // Session summary
      let sessionStartTime = 0;
      let sessionBeats = 0;
      let sessionMeasures = 0;

      // === Notation state ===
      let vfFactory = null;
      let vfContext = null;
      let lastNotationState = null;

      // === Visualization state ===
      let visualAnimationId = null;
      let ballAnimationStart = 0;
      let currentBeatForVis = 0;
      let pendulumDirection = 1; // 1 = right, -1 = left

      // Session UI refs
      const sessionBeatsEl = $('sessionBeats');
      const sessionMeasuresEl = $('sessionMeasures');
      const sessionTimeEl = $('sessionTime');
      const sessionAvgBpmEl = $('sessionAvgBpm');

      function initNotation() {
        if (vfFactory) return;
        const VF = Vex.Flow;
        vfFactory = new VF.Factory({ 
          renderer: { 
            elementId: 'notation', 
            width: 420, 
            height: 120 
          } 
        });
        vfContext = vfFactory.getContext();
      }

      function clearNotation() {
        if (vfFactory) {
          notationDiv.innerHTML = '';
          vfFactory = null;
          vfContext = null;
        }
      }

      function getNotationState() {
        return {
          meter: currentMeter,
          subdivision: currentSubdivision,
          timeSignature: tsSel.value,
          polyEnabled: polyEnableChk.checked,
          polyCount: +polyCountInput.value
        };
      }

      function hasNotationStateChanged() {
        const newState = getNotationState();
        if (!lastNotationState) return true;
        
        return Object.entries(newState).some(([key, value]) => 
          lastNotationState[key] !== value
        );
      }

      /* ---------- Grouping presets ---------- */
      const groupingOpts = {
        5: [[2,3],[3,2]],
        7: [[2,2,3],[2,3,2],[3,2,2]],
        11: [[3,3,3,2],[3,3,2,3],[3,2,3,3],[2,3,3,3]],
        13: [[3,3,3,2,2],[3,3,2,3,2],[3,2,3,3,2],[2,3,3,3,2]],
        6: [[3,3]],
        9: [[3,3,3],[2,2,2,3]],
        12: [[3,3,3,3]]
      };
      function updateGroupingOpts() {
        const prev = groupingSel.value;
        const num = parseInt(tsSel.value, 10);
        groupingSel.innerHTML = "<option value=''>‚ÄîManual‚Äî</option>";
        (groupingOpts[num] || []).forEach(g => {
          const opt = document.createElement('option');
          opt.value = g.join(',');
          let label = g.join(' + ');
          if (num === 6 && g.join(',') === '3,3') label += ' (duple)';
          if (num === 9 && g.join(',') === '3,3,3') label += ' (triple)';
          if (num === 12 && g.join(',') === '3,3,3,3') label += ' (quadruple)';
          opt.textContent = label;
          groupingSel.appendChild(opt);
        });
        if (prev && [...groupingSel.options].some(o => o.value === prev))
          groupingSel.value = prev;
      }
      function getAccentState() {
        return {
          checked: accentBoxes.map(cb => cb.checked),
          tones: accentToneBoxes.map(sel => sel.value)
        };
      }
      function applyAccentState(state) {
        if (!state) return;
        const len = Math.min(state.checked.length, accentBoxes.length);
        for (let i = 0; i < len; i++) {
          accentBoxes[i].checked = !!state.checked[i];
          accentToneBoxes[i].value = state.tones[i] || accentToneSel.value;
        }
      }
      function rebuildAccentsPreservingState() {
        const state = retainAccentsChk.checked ? getAccentState() : null;
        updateGroupingOpts();
        updateAccentPattern();
        if (state) applyAccentState(state);
      }
      function cloneToneSelect() {
        const sel = document.createElement('select');
        accentToneSel.querySelectorAll('option').forEach(o => {
          const opt = document.createElement('option');
          opt.value = o.value; opt.textContent = o.textContent;
          sel.appendChild(opt);
        });
        sel.value = accentToneSel.value;
        return sel;
      }
      function clonePitchSelect() {
        const sel = document.createElement('select');
        const notes = ['C4','C#4','D4','D#4','E4','F4','F#4','G4','G#4','A4','A#4','B4','C5'];
        notes.forEach(n => sel.appendChild(new Option(n, n)));
        return sel;
      }
      function updateAccentPattern() {
        accentCont.innerHTML = ''; accentBoxes = []; accentToneBoxes = [];
        const beats = currentMeter;
        const checks = Array(beats).fill(false);
        if (groupingSel.value) {
          let idx = 0;
          groupingSel.value.split(',').map(Number)
            .forEach(n => { checks[idx] = true; idx += n; });
        } else checks[0] = true;
        checks.forEach((on, i) => {
          const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = on;
          const toneSel = cloneToneSelect();
          const lbl = document.createElement('label');
          lbl.textContent = i+1;
          lbl.appendChild(cb);
          lbl.appendChild(toneSel);
          accentCont.appendChild(lbl);
          accentBoxes.push(cb); accentToneBoxes.push(toneSel);
        });
      }

      function renderMeasurePitchControls() {
        const count = Math.max(1, parseInt(measureCountInput.value, 10) || 1);
        measurePitchesDiv.innerHTML = '';
        measurePitchSelects = [];
        for (let i = 0; i < count; i++) {
          const lbl = document.createElement('label');
          lbl.textContent = `M${i + 1}`;
          const sel = clonePitchSelect();
          lbl.appendChild(sel);
          measurePitchesDiv.appendChild(lbl);
          measurePitchSelects.push(sel);
        }
      }

      /* ---------- Tempo-change table ---------- */
      function renderTempoChanges() {
        tableBody.innerHTML = '';
        tempoChanges.forEach((r, i) => {
          const tr = document.createElement('tr');
          tr.innerHTML =
            `<td>${r.startMeasure}</td>` +
            `<td>${r.type}</td>` +
            `<td>${Math.round(r.newBpm)}</td>` +
            `<td>${r.newMeter || '‚Äî'}</td>` +
            `<td>${r.duration}</td>` +
            `<td><button class='remove-change' data-i='${i}'>‚úï</button></td>`;
          tableBody.appendChild(tr);
        });
        document.querySelectorAll('.remove-change').forEach(btn => {
          btn.onclick = () => { tempoChanges.splice(+btn.dataset.i, 1); renderTempoChanges(); };
        });
      }
      addChangeBtn.onclick = () => {
        const rule = {
          startMeasure: Math.max(1, parseInt(changeStart.value, 10)),
          type: changeType.value,
          newBpm: Math.max(1, parseInt(changeBpm.value, 10)),
          newMeter: changeMeter.value || null,
          duration: Math.max(1, parseInt(changeDur.value, 10)),
          _inProgress: false, _meterChanged: false, _applied: false
        };
        tempoChanges.push(rule);
        tempoChanges.sort((a, b) => a.startMeasure - b.startMeasure);
        renderTempoChanges();
        if (DEBUG) console.log('Added tempo change', rule);
      };

      /* ---------- VexFlow drawing ---------- */
      function drawNotation(barTick) {
        try {
          // Initialize or reinitialize if state changed
          if (!vfFactory || hasNotationStateChanged()) {
            clearNotation();
            initNotation();
            lastNotationState = getNotationState();
          }

          const VF = Vex.Flow;
          const context = vfContext;
          
          // Clear previous drawing
          context.clear();
          
          const stave = new VF.Stave(10, 40, 400);
          stave.addClef('percussion').addTimeSignature(tsSel.value);
          stave.setContext(context).draw();

          // Map subdivisions to note durations and create groups
          const durMap = {
            1: { duration: 'q', groupSize: 1, perBeat: 1 },    // quarter notes
            2: { duration: '8', groupSize: 2, perBeat: 2 },    // eighth notes
            3: { duration: '8', groupSize: 3, perBeat: 3 },    // triplets
            4: { duration: '16', groupSize: 4, perBeat: 4 },   // sixteenth notes
            5: { duration: '16', groupSize: 5, perBeat: 5 }    // quintuplets
          };
          
          const { duration, groupSize, perBeat } = durMap[currentSubdivision] || durMap[1];
          const beatsInBar = parseInt(tsSel.value);
          const total = beatsInBar * perBeat;
          
          // Create notes with proper styling
          const notes = [];
          const tupletGroups = [];
          
          for (let beat = 0; beat < beatsInBar; beat++) {
            const beatNotes = [];
            for (let i = 0; i < perBeat; i++) {
              const globalIndex = beat * perBeat + i;
              const note = new VF.StaveNote({ 
                keys: ['b/4'], 
                duration: duration + (globalIndex === barTick ? '' : 'r') // Use rests for non-current beats
              });
              
              // Add styling for the current beat
              if (globalIndex === barTick) {
                note.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
              }
              
              // Add dots for compound meters (6/8, 9/8, 12/8)
              if (tsSel.value.endsWith('/8') && duration === 'q') {
                note.addDot(0);
              }
              
              beatNotes.push(note);
              notes.push(note);
            }
            
            // Create tuplets/beams for each beat group
            if (groupSize > 1) {
              if (perBeat === 3) {
                // Create tuplet for triplets
                const tuplet = new VF.Tuplet(beatNotes, {
                  num_notes: 3,
                  notes_occupied: 2
                });
                tupletGroups.push(tuplet);
              } else if (perBeat === 5) {
                // Create tuplet for quintuplets
                const tuplet = new VF.Tuplet(beatNotes, {
                  num_notes: 5,
                  notes_occupied: 4
                });
                tupletGroups.push(tuplet);
              } else if (beatNotes.length > 1) {
                // Create beam for regular groupings
                const beam = new VF.Beam(beatNotes);
                tupletGroups.push(beam);
              }
            }
          }

          // Create voice with proper timing
          let voice;
          if (tsSel.value.endsWith('/8')) {
            // Compound meter (6/8, 9/8, 12/8)
            voice = new VF.Voice({ 
              num_beats: beatsInBar/3, 
              beat_value: 4,
              resolution: VF.RESOLUTION 
            }).addTickables(notes);
          } else {
            // Simple meter
            voice = new VF.Voice({ 
              num_beats: beatsInBar, 
              beat_value: 4,
              resolution: VF.RESOLUTION 
            }).addTickables(notes);
          }

          // Format and draw
          new VF.Formatter()
            .joinVoices([voice])
            .format([voice], 380);
          
          voice.draw(context, stave);
          tupletGroups.forEach(group => group.setContext(context).draw());

          // Draw polyrhythm markers if enabled
          if (polyEnableChk.checked) {
            const num = parseInt(polyCountInput.value, 10);
            crossPositions = [];
            for (let i = 0; i < num; i++) {
              crossPositions.push(Math.round((i * total) / num));
            }
            
            // Add polyrhythm markers using VexFlow annotations
            const markerNotes = notes.filter((_, i) => crossPositions.includes(i));
            markerNotes.forEach(note => {
              note.addModifier(new VF.Annotation('√ó')
                .setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM)
                .setFont('Arial', 12, 'bold'));
            });
          }
        } catch (err) {
          console.error('Failed to draw notation:', err);
          // Fallback to simpler visualization if VexFlow fails
          clearNotation();
          const div = document.createElement('div');
          div.style.width = '100%';
          div.style.height = '100%';
          div.style.display = 'flex';
          div.style.alignItems = 'center';
          div.style.justifyContent = 'center';
          div.textContent = `Beat ${barTick + 1} of ${currentMeter * currentSubdivision}`;
          notationDiv.appendChild(div);
        }
      }

      /* ---------- Swing helpers ---------- */
      function computeSwingFactor(posInBeat) {
        const type = swingTypeSel.value;
        const amt = Math.max(0, Math.min(1, parseFloat(swingAmtCtrl.value) || 0));
        if (type === '8' && currentSubdivision === 2) {
          // Map 0..1 to 1:1 .. 2:1
          const r = 1 + amt; // ratio long:short
          const p = r / (1 + r); // first fraction of the pair
          return (posInBeat % 2 === 0) ? (2 * p) : (2 * (1 - p));
        }
        if (type === '16' && currentSubdivision === 4) {
          const r = 1 + amt;
          const p = r / (1 + r);
          // Pairs: (0,1) and (2,3)
          return (posInBeat % 2 === 0) ? (2 * p) : (2 * (1 - p));
        }
        return 1;
      }
      function tickDurationSec(posInBeat) {
        const base = 60 / currentBpm / currentSubdivision;
        return base * computeSwingFactor(posInBeat);
      }

      /* ---------- Session helpers ---------- */
      function fmtTime(ms) {
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const ss = s % 60;
        return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
      }
      function updateSessionUI() {
        if (!sessionStartTime) return;
        const elapsed = Date.now() - sessionStartTime;
        sessionBeatsEl.textContent = String(sessionBeats);
        sessionMeasuresEl.textContent = String(sessionMeasures);
        sessionTimeEl.textContent = fmtTime(elapsed);
        const minutes = elapsed / 60000;
        const avg = minutes > 0 ? Math.round(sessionBeats / minutes) : 0;
        sessionAvgBpmEl.textContent = String(avg);
      }

      /* ---------- Sound helpers ---------- */
      function playWood(vol) {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const now = audioCtx.currentTime;
        const src = audioCtx.createBufferSource(); src.buffer = noiseBuf;
        const filt = audioCtx.createBiquadFilter(); filt.type = 'bandpass'; filt.frequency.value = 2000; filt.Q.value = 5;
        const gain = audioCtx.createGain();
        src.connect(filt); filt.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        src.start(now); src.stop(now + 0.05);
      }
      function playKick(vol) {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
      }
      function playSnare(vol) {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const now = audioCtx.currentTime;
        const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
        const band = audioCtx.createBiquadFilter(); band.type = 'bandpass'; band.frequency.value = 1000; band.Q.value = 0.7;
        const gain = audioCtx.createGain();
        noise.connect(band); band.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
        noise.start(now); noise.stop(now + 0.2);
      }
      function playHiHat(vol) {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const now = audioCtx.currentTime;
        const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
        const high = audioCtx.createBiquadFilter(); high.type = 'highpass'; high.frequency.value = 6000;
        const gain = audioCtx.createGain();
        noise.connect(high); high.connect(gain); gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        noise.start(now); noise.stop(now + 0.05);
      }
      function oscType(name) { return name === 'click' ? 'square' : name === 'tick' ? 'sine' : 'triangle'; }
      function oscFreq(name) { return name === 'click' ? 1000 : name === 'tick' ? 600 : 1200; }
      async function playTone(name, vol) {
        // Ensure context is running; if resuming is blocked, skip this tick
        await ensureAudio();
        if (!audioCtx || audioCtx.state !== 'running') return;
        if (name === 'wood')   return playWood(vol);
        if (name === 'kick')   return playKick(vol);
        if (name === 'snare')  return playSnare(vol);
        if (name === 'hihat')  return playHiHat(vol);
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
        let filt;
        if (name === 'click') {
          filt = audioCtx.createBiquadFilter(); 
          filt.type = 'highpass'; 
          filt.frequency.value = 1500;
          osc.connect(filt); 
          filt.connect(gain);
        } else osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = oscType(name); 
        osc.frequency.setValueAtTime(oscFreq(name), now);
        gain.gain.setValueAtTime(0, now); 
        gain.gain.linearRampToValueAtTime(vol, now + 0.001);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);
        osc.start(now); 
        osc.stop(now + 0.03);
        
        // Clean up nodes
        setTimeout(() => {
          osc.disconnect();
          gain.disconnect();
          if (filt) filt.disconnect();
        }, 50);
      }

      /* ---------- Count-in functionality ---------- */
      let isCountingIn = false;
      
      async function playCountIn(countInValue) {
        await ensureAudio();
        if (!audioCtx || audioCtx.state !== 'running') return;
        
        isCountingIn = true;
        const bpm = +bpmInput.value;
        const meter = parseInt(tsSel.value.split('/')[0], 10);
        const beatDuration = 60 / bpm;
        
        // Determine number of count-in beats
        let countInBeats;
        if (countInValue === '1bar') {
          countInBeats = meter;
        } else if (countInValue === '2bar') {
          countInBeats = meter * 2;
        } else {
          countInBeats = parseInt(countInValue, 10);
        }
        
        // Create visual feedback element
        const countInDisplay = document.createElement('div');
        countInDisplay.id = 'countInDisplay';
        countInDisplay.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 120px;
          font-weight: bold;
          color: var(--accent-color, #e74c3c);
          z-index: 10000;
          text-shadow: 0 4px 20px rgba(0,0,0,0.3);
          pointer-events: none;
          animation: countInPulse 0.3s ease-out;
        `;
        document.body.appendChild(countInDisplay);
        
        // Add animation style if not present
        if (!document.getElementById('countInStyle')) {
          const style = document.createElement('style');
          style.id = 'countInStyle';
          style.textContent = `
            @keyframes countInPulse {
              0% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
              100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
          `;
          document.head.appendChild(style);
        }
        
        // Play count-in beats
        for (let i = 0; i < countInBeats; i++) {
          if (!isCountingIn) break; // Allow cancellation
          
          const beatNum = (i % meter) + 1;
          const isAccent = beatNum === 1;
          
          // Update display
          countInDisplay.textContent = beatNum;
          countInDisplay.style.animation = 'none';
          countInDisplay.offsetHeight; // Trigger reflow
          countInDisplay.style.animation = 'countInPulse 0.3s ease-out';
          
          // Play sound
          const tone = isAccent ? accentToneSel.value : toneSel.value;
          const vol = isAccent ? +accentVolCtrl.value : +volCtrl.value;
          playTone(tone, vol);
          
          // Flash the beat visualizer if visible
          const flashDot = document.getElementById('flashDot');
          if (flashDot) {
            flashDot.style.transform = 'scale(1.3)';
            flashDot.style.background = isAccent ? 'var(--accent-color, #e74c3c)' : 'var(--text-primary, #333)';
            setTimeout(() => {
              flashDot.style.transform = 'scale(1)';
            }, 100);
          }
          
          // Wait for next beat
          await new Promise(resolve => setTimeout(resolve, beatDuration * 1000));
        }
        
        // Remove display
        countInDisplay.remove();
        isCountingIn = false;
      }
      
      function schedulePolyBeats(barStartTime) {
        if (!polyEnableChk.checked) return;
        const count = parseInt(polyCountInput.value, 10);
        if (count <= 1) return;
        
        // Clear any existing scheduled beats
        const now = audioCtx.currentTime;
        if (now > barStartTime) return; // Don't schedule if we're late
        
        // Clean up previously scheduled beats
        scheduledPolyBeats.forEach(node => {
          try {
            if (node.osc) node.osc.stop();
            if (node.gain) node.gain.disconnect();
            if (node.filt) node.filt.disconnect();
          } catch (err) {
            console.error('Error cleaning up poly beat:', err);
          }
        });
        scheduledPolyBeats = [];
        
        const barDuration = (60 / currentBpm) * currentMeter; // seconds per bar
        for (let i = 1; i < count; i++) {
          const when = barStartTime + (i / count) * barDuration;
          if (when > now) { // Only schedule future beats
            const nodes = playToneAtTime(polyToneSel.value, +polyVolCtrl.value, when);
            if (nodes) scheduledPolyBeats.push(nodes);
          }
        }
      }
      async function playToneAtTime(name, vol, when) {
        await ensureAudio();
        if (!audioCtx || audioCtx.state !== 'running') return null;
        const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
        let filt;
        if (name === 'click') {
          filt = audioCtx.createBiquadFilter(); filt.type = 'highpass'; filt.frequency.value = 1500;
          osc.connect(filt); filt.connect(gain);
        } else osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = oscType(name); osc.frequency.setValueAtTime(oscFreq(name), when);
        gain.gain.setValueAtTime(0, when); gain.gain.linearRampToValueAtTime(vol, when + 0.001);
        gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.03);
        osc.start(when); osc.stop(when + 0.03);

        return { osc, gain, filt };
      }

      function noteToFreq(note) {
        const map = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
        const m = note.match(/^([A-G])(#?)(\d)$/);
        if (!m) return 440;
        const [ , l, sharp, oct ] = m;
        const n = (parseInt(oct,10)+1)*12 + map[l] + (sharp ? 1:0);
        return 440 * Math.pow(2, (n-69)/12);
      }

      let currentHum = null;
      function startHum(note) {
        ensureAudio();
        const targetVol = +humVolCtrl.value;
        const now = audioCtx.currentTime;
        const fade = 0.08;
        const freq = noteToFreq(note);
        const createHum = (when) => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, when);
          gain.gain.setValueAtTime(0, when);
          osc.connect(gain); gain.connect(audioCtx.destination);
          osc.start(when);
          gain.gain.linearRampToValueAtTime(targetVol, when + fade);
          return { osc, gain };
        };
        if (currentHum) {
          const old = currentHum;
          const newHum = createHum(now);
          currentHum = newHum;
          try {
            old.gain.gain.setValueAtTime(old.gain.gain.value, now);
            old.gain.gain.linearRampToValueAtTime(0.0001, now + fade);
            old.osc.stop(now + fade);
          } catch (e) {
            console.error('Error crossfading hum:', e);
          }
          setTimeout(() => {
            try { old.osc.disconnect(); old.gain.disconnect(); } catch {}
          }, Math.ceil((fade + 0.05) * 1000));
        } else {
          currentHum = createHum(now);
        }
      }
      function stopHum() {
          if (!currentHum) return;
          const hum = currentHum;
          currentHum = null;
          const now = audioCtx.currentTime;
          try {
            hum.gain.gain.setValueAtTime(hum.gain.gain.value, now);
            hum.gain.gain.linearRampToValueAtTime(0.0001, now + 0.05);
            hum.osc.stop(now + 0.05);
          } catch (e) {
            console.error('Error stopping hum oscillator:', e);
          }
          setTimeout(() => {
            try {
              if (hum.osc) hum.osc.disconnect();
              if (hum.gain) hum.gain.disconnect();
            } catch (err) {
              console.error('Error cleaning up hum nodes:', err);
            }
          }, 100);
        }


      /* ---------- Beat Visualizations ---------- */
      function updateVisualization(type) {
        if (type === 'none') {
          beatVisualizer.classList.add('hidden');
          ballContainer.style.display = 'none';
          pendulumContainer.style.display = 'none';
        } else if (type === 'ball') {
          beatVisualizer.classList.remove('hidden');
          ballContainer.style.display = 'flex';
          pendulumContainer.style.display = 'none';
          updateBeatMarkers();
        } else if (type === 'pendulum') {
          beatVisualizer.classList.remove('hidden');
          ballContainer.style.display = 'none';
          pendulumContainer.style.display = 'flex';
          resetPendulum();
        }
      }

      function updateBeatMarkers() {
        beatMarkersDiv.innerHTML = '';
        for (let i = 0; i < currentMeter; i++) {
          const marker = document.createElement('div');
          marker.className = 'beat-marker';
          if (accentBoxes[i] && accentBoxes[i].checked) {
            marker.classList.add('accent-marker');
          }
          beatMarkersDiv.appendChild(marker);
        }
      }

      function animateBounce(beatIndex, isAccent) {
        if (visualTypeSel.value !== 'ball') return;
        
        // Update beat markers
        const markers = beatMarkersDiv.querySelectorAll('.beat-marker');
        markers.forEach((m, i) => {
          m.classList.toggle('active', i === beatIndex);
        });

        // Animate the ball
        bouncingBall.classList.toggle('accent', isAccent);
        
        const bpm = currentBpm;
        const beatDuration = 60000 / bpm; // ms per beat
        
        // Cancel any existing animation
        if (visualAnimationId) {
          cancelAnimationFrame(visualAnimationId);
        }

        ballAnimationStart = performance.now();
        
        function animateBall(now) {
          const elapsed = now - ballAnimationStart;
          const progress = Math.min(elapsed / beatDuration, 1);
          
          // Parabolic bounce: y = 4h * p * (1 - p) where p is progress and h is max height
          const maxHeight = 120; // pixels
          const y = maxHeight * 4 * progress * (1 - progress);
          
          // Shadow scales inversely with height
          const shadowScale = 1 - (y / maxHeight) * 0.5;
          
          bouncingBall.style.transform = `translateY(-${y}px)`;
          ballShadow.style.transform = `scale(${shadowScale})`;
          ballShadow.style.opacity = shadowScale;
          
          if (progress < 1) {
            visualAnimationId = requestAnimationFrame(animateBall);
          }
        }
        
        visualAnimationId = requestAnimationFrame(animateBall);
      }

      function animatePendulum(beatIndex) {
        if (visualTypeSel.value !== 'pendulum') return;
        
        const bpm = currentBpm;
        const beatDuration = 60000 / bpm;
        
        if (visualAnimationId) {
          cancelAnimationFrame(visualAnimationId);
        }

        ballAnimationStart = performance.now();
        const startAngle = pendulumDirection * 30; // degrees
        const endAngle = -pendulumDirection * 30;
        
        function animatePend(now) {
          const elapsed = now - ballAnimationStart;
          const progress = Math.min(elapsed / beatDuration, 1);
          
          // Ease in-out for natural swing feel
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          const angle = startAngle + (endAngle - startAngle) * eased;
          pendulumArm.style.transform = `rotate(${angle}deg)`;
          
          if (progress < 1) {
            visualAnimationId = requestAnimationFrame(animatePend);
          } else {
            pendulumDirection *= -1; // Reverse for next beat
          }
        }
        
        visualAnimationId = requestAnimationFrame(animatePend);
      }

      function resetPendulum() {
        pendulumDirection = 1;
        pendulumArm.style.transform = 'rotate(30deg)';
      }

      function stopVisualization() {
        if (visualAnimationId) {
          cancelAnimationFrame(visualAnimationId);
          visualAnimationId = null;
        }
        // Reset ball position
        bouncingBall.style.transform = 'translateY(0)';
        ballShadow.style.transform = 'scale(1)';
        ballShadow.style.opacity = 1;
        // Clear beat markers
        beatMarkersDiv.querySelectorAll('.beat-marker').forEach(m => m.classList.remove('active'));
        // Reset pendulum
        resetPendulum();
      }

      // Initialize visualization on load
      visualTypeSel.onchange = () => updateVisualization(visualTypeSel.value);


      /* ---------- Focus Mode ---------- */
      const focusMode = $('focusMode');
      const focusModeBtn = $('focusModeBtn');
      const focusVisualizer = $('focusVisualizer');
      const focusBeatCounter = $('focusBeatCounter');
      const focusBpm = $('focusBpm');
      const focusMeter = $('focusMeter');
      const focusPlayPause = $('focusPlayPause');
      const focusExit = $('focusExit');
      const focusBpmUp = $('focusBpmUp');
      const focusBpmDown = $('focusBpmDown');
      let inFocusMode = false;
      let focusBeatIndex = 0;

      function enterFocusMode() {
        inFocusMode = true;
        focusMode.style.display = 'flex';
        
        // Clone the current visualization into focus mode
        const visType = visualTypeSel.value;
        focusVisualizer.innerHTML = '';
        
        if (visType === 'ball' || visType === 'none') {
          focusVisualizer.innerHTML = `
            <div class="bouncing-ball-container">
              <div class="bouncing-ball-shadow" id="focusBallShadow"></div>
              <div class="bouncing-ball" id="focusBouncingBall"></div>
              <div class="beat-markers" id="focusBeatMarkers"></div>
            </div>
          `;
          // Rebuild markers for focus mode
          const markersDiv = $('focusBeatMarkers');
          for (let i = 0; i < currentMeter; i++) {
            const marker = document.createElement('div');
            marker.className = 'beat-marker';
            if (accentBoxes[i] && accentBoxes[i].checked) {
              marker.classList.add('accent-marker');
            }
            markersDiv.appendChild(marker);
          }
        } else if (visType === 'pendulum') {
          focusVisualizer.innerHTML = `
            <div class="pendulum-container">
              <div class="pendulum-tick-left"></div>
              <div class="pendulum-tick-right"></div>
              <div class="pendulum-pivot"></div>
              <div class="pendulum-arm" id="focusPendulumArm">
                <div class="pendulum-weight"></div>
              </div>
            </div>
          `;
        }
        
        // Update info display
        focusBpm.textContent = currentBpm;
        focusMeter.textContent = tsSel.value;
        focusBeatCounter.textContent = '-';
        focusPlayPause.textContent = startBtn.disabled ? '‚èπ Stop' : '‚ñ∂ Start';
        
        // Request fullscreen
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      }

      function exitFocusMode() {
        inFocusMode = false;
        focusMode.style.display = 'none';
        focusBeatCounter.textContent = '-';
        
        // Exit fullscreen
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        }
      }

      function updateFocusBeatDisplay(beatIdx, isAccent) {
        if (!inFocusMode) return;
        
        focusBeatCounter.textContent = beatIdx + 1;
        focusBpm.textContent = currentBpm;
        
        // Animate ball in focus mode
        const focusBall = $('focusBouncingBall');
        const focusShadow = $('focusBallShadow');
        const focusMarkers = $('focusBeatMarkers');
        
        if (focusBall) {
          focusBall.classList.toggle('accent', isAccent);
          
          const bpm = currentBpm;
          const beatDuration = 60000 / bpm;
          const startTime = performance.now();
          
          function animateFocusBall(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / beatDuration, 1);
            const maxHeight = 200;
            const y = maxHeight * 4 * progress * (1 - progress);
            const shadowScale = 1 - (y / maxHeight) * 0.5;
            
            focusBall.style.transform = `translateY(-${y}px)`;
            if (focusShadow) {
              focusShadow.style.transform = `scale(${shadowScale})`;
              focusShadow.style.opacity = shadowScale;
            }
            
            if (progress < 1 && inFocusMode) {
              requestAnimationFrame(animateFocusBall);
            }
          }
          requestAnimationFrame(animateFocusBall);
        }
        
        // Update markers
        if (focusMarkers) {
          focusMarkers.querySelectorAll('.beat-marker').forEach((m, i) => {
            m.classList.toggle('active', i === beatIdx);
          });
        }
        
        // Animate pendulum in focus mode
        const focusPendulum = $('focusPendulumArm');
        if (focusPendulum) {
          const bpm = currentBpm;
          const beatDuration = 60000 / bpm;
          const startTime = performance.now();
          const startAngle = pendulumDirection * 30;
          const endAngle = -pendulumDirection * 30;
          
          function animateFocusPendulum(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / beatDuration, 1);
            const eased = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            const angle = startAngle + (endAngle - startAngle) * eased;
            focusPendulum.style.transform = `rotate(${angle}deg)`;
            
            if (progress < 1 && inFocusMode) {
              requestAnimationFrame(animateFocusPendulum);
            } else if (progress >= 1) {
              pendulumDirection *= -1;
            }
          }
          requestAnimationFrame(animateFocusPendulum);
        }
      }

      focusModeBtn.onclick = enterFocusMode;
      focusExit.onclick = exitFocusMode;
      
      focusPlayPause.onclick = async () => {
        if (startBtn.disabled) {
          await stopMetronome();
          focusPlayPause.textContent = '‚ñ∂ Start';
        } else {
          await startMetronome();
          focusPlayPause.textContent = '‚èπ Stop';
        }
      };
      
      focusBpmUp.onclick = () => {
        const newBpm = Math.min(300, currentBpm + (event.shiftKey ? 10 : 1));
        bpmInput.value = newBpm;
        currentBpm = newBpm;
        focusBpm.textContent = newBpm;
      };
      
      focusBpmDown.onclick = () => {
        const newBpm = Math.max(30, currentBpm - (event.shiftKey ? 10 : 1));
        bpmInput.value = newBpm;
        currentBpm = newBpm;
        focusBpm.textContent = newBpm;
      };
      
      // Exit focus mode on Escape
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && inFocusMode) {
          exitFocusMode();
        }
      });
      
      // Handle fullscreen exit (e.g., user presses F11)
      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && inFocusMode) {
          // Stay in focus mode but without fullscreen
        }
      });


        function isMeasureMuted(num) {
        const playM = +playMeasuresInput.value;
        const muteM = +muteMeasuresInput.value;
        if (playM > 0 && muteM >= 0) {
          const cycleLen = playM + muteM;
          const idx = (num - 1) % cycleLen;
          return idx >= playM;
        }
        return false;
      }
      /* ---------- Scheduler ---------- */
      function doTick() {
        const sub = currentSubdivision;
        const isMain = (ticks % sub === 0);
        if (isMain) {
          mainBeats++;
          // Visual feedback for main beat
          startBtn.classList.remove('beat-flash');
          void startBtn.offsetWidth; // Force reflow
          startBtn.classList.add('beat-flash');
          
          // Animate beat visualization
          const beatIdx = Math.floor(ticksInMeasure / sub);
          const isAccent = accentBoxes[beatIdx] && accentBoxes[beatIdx].checked;
          animateBounce(beatIdx, isAccent);
          animatePendulum(beatIdx);
          
          // Update focus mode display
          updateFocusBeatDisplay(beatIdx, isAccent);
        } else {
          // Visual feedback for subdivision
          startBtn.classList.remove('sub-flash');
          void startBtn.offsetWidth; // Force reflow
          startBtn.classList.add('sub-flash');
        }
        const beatIdx = Math.floor(ticksInMeasure / sub);

        // Drift correction (base interval before swing)
        const baseInterval = (60 / currentBpm) * 1000 / sub;
        const expectedTime = startTime + (ticks * baseInterval);
        const actualTime = Date.now();
        const drift = actualTime - expectedTime;
        let interval = baseInterval;
        
        // Adjust interval to correct for drift
        if (Math.abs(drift) > 1) { // Only correct if drift is more than 1ms
          interval = Math.max(0, interval - drift);
        }
        // Apply swing after drift compensation (when applicable)
        const posInBeat = ticks % sub;
        interval *= computeSwingFactor(posInBeat);

        /* ----- measure loop ----- */
        const measureMuted = isMeasureMuted(measureCount);

        /* ----- tempo-changes ----- */
        let tempoChangeApplied = false;
        tempoChanges.forEach(r => {
          if (tempoChangeApplied) return;
          /** Sudden **/
          if (r.type === 'sudden' && !r._applied && isMain && measureCount === r.startMeasure) {
            currentBpm = r.newBpm;
            if (r.newMeter) {
              currentMeter = parseInt(r.newMeter.split('/')[0], 10);
              tsSel.value = r.newMeter;
              rebuildAccentsPreservingState();
            }
            ticksInMeasure = 0;
            r._applied = true;
            tempoChangeApplied = true;
            // Reset timing reference on sudden tempo change
            startTime = Date.now();
            ticks = 0;
            if (DEBUG) console.log('Sudden change applied', { currentBpm, currentMeter });
          }
          /** Gradual **/
          if (r.type === 'gradual' && !tempoChangeApplied) {
            const totalBeats = r.duration * currentMeter;
            const startBeat = (r.startMeasure - 1) * currentMeter;
            if (mainBeats >= startBeat && mainBeats <= startBeat + totalBeats) {
              if (!r._inProgress) { r._inProgress = true; r._initialBpm = currentBpm; }
              const ratio = (mainBeats - startBeat) / totalBeats;
              currentBpm = r._initialBpm + ratio * (r.newBpm - r._initialBpm);
              if (r.newMeter && ratio >= 1 && !r._meterChanged) {
                currentMeter = parseInt(r.newMeter.split('/')[0], 10);
                tsSel.value = r.newMeter;
                rebuildAccentsPreservingState();
                r._meterChanged = true;
                ticksInMeasure = 0;
                tempoChangeApplied = true;
                // Reset timing reference on meter change
                startTime = Date.now();
                ticks = 0;
              }
            }
          }
        });

        /* ----- play sound ----- */
        if (!measureMuted) {
          const accent = accentBoxes[beatIdx]?.checked ?? false;
          const selectedTone = accent ? (accentToneBoxes[beatIdx]?.value || accentToneSel.value) : toneSel.value;
          if (!audioCtx) initAudio();
          const when = (audioCtx && audioCtx.state === 'running')
            ? Math.max(audioCtx.currentTime, nextClickTimeSec || (audioCtx.currentTime + 0.01))
            : null;
          if (isMain) {
            if (when != null) {
              playToneAtTime(selectedTone, accent ? +accentVolCtrl.value : +volCtrl.value, when);
            } else {
              playTone(selectedTone, accent ? +accentVolCtrl.value : +volCtrl.value);
            }
            sessionBeats++;
            updateSessionUI();
          } else {
            if (when != null) {
              playToneAtTime(subToneSel.value, +subVolCtrl.value, when);
            } else {
              playTone(subToneSel.value, +subVolCtrl.value);
            }
          }
        }

        // Polyrhythm
        if (polyEnableChk.checked) {
          for (const pos of crossPositions) {
            if (ticksInMeasure === pos) {
              // Polyrhythm clicks are scheduled at exact times already
              playTone(polyToneSel.value, +polyVolCtrl.value);
            }
          }
        }

        /* ----- debug log ----- */
        if (DEBUG && isMain) {
          console.log(`Measure ${measureCount}, Beat ${beatIdx + 1}/${currentMeter}, muted=${measureMuted}, drift=${drift}ms`);
        }

        /* ----- update notation & counters ----- */
        drawNotation(ticksInMeasure);
        const prevMeasureMuted = measureMuted;
        ticks++; ticksInMeasure++;
        // advance audio schedule for next tick
        nextClickTimeSec = (audioCtx && audioCtx.state === 'running')
          ? (nextClickTimeSec || (audioCtx.currentTime + 0.01)) + tickDurationSec(posInBeat)
          : 0;

        // Reset on new measure
        if (ticksInMeasure >= currentMeter * currentSubdivision) {
          ticksInMeasure = 0;
          measureCount++;
          sessionMeasures++;
          // Subdivision drill progression
          if (drillEnableChk.checked) {
            drillMeasureCounter++;
            const perStep = Math.max(1, parseInt(drillMeasuresInput.value, 10) || 1);
            if (drillMeasureCounter >= perStep) {
              drillMeasureCounter = 0;
              drillIndex = (drillIndex + 1) % drillCycle.length;
              const nextSub = drillCycle[drillIndex];
              currentSubdivision = nextSub;
              subdivisionSel.value = String(nextSub);
              drawNotation(0);
            }
          }
          const now = audioCtx.currentTime;
          schedulePolyBeats(now);
          const nowMuted = isMeasureMuted(measureCount);
          if (!nowMuted) {
            const pitch = measurePitchSelects[(measureCount - 1) % measurePitchSelects.length]?.value || 'C4';
            startHum(pitch);
          } else {
            stopHum();
          }
          if (checkpointBeepChk.checked && prevMeasureMuted && !nowMuted) {
            playTone('bell', Math.min(1, (+accentVolCtrl.value || +volCtrl.value)));
          }
        }
        
        timerId = setTimeout(doTick, interval);
      }

      async function startMetronome() {
        try {
          // Check for count-in
          const countInValue = countInSel.value;
          if (countInValue !== '0') {
            await playCountIn(countInValue);
          }
          
          // reset state
          ticks = mainBeats = 0;
          ticksInMeasure = 0; measureCount = 1;
          tempoChanges.forEach(r => { r._inProgress = r._meterChanged = r._applied = false; });
          currentBpm = +bpmInput.value; currentSubdivision = +subdivisionSel.value;
          currentMeter = parseInt(tsSel.value.split('/')[0], 10);
          // Keep existing accent settings intact when starting
          updateGroupingOpts();
          drawNotation(0);
          // Initialize/unlock audio in response to user action
          await ensureAudio();
          nextClickTimeSec = (audioCtx && audioCtx.state === 'running') ? audioCtx.currentTime + 0.05 : 0;
          
          startTime = Date.now(); // Initialize start time
          // Init session metrics
          sessionStartTime = startTime;
          sessionBeats = 0;
          sessionMeasures = 0;
          // Init drill
          drillIndex = drillCycle.indexOf(currentSubdivision);
          if (drillIndex < 0) drillIndex = 0;
          drillMeasureCounter = 0;
          schedulePolyBeats(audioCtx.currentTime);
          if (!isMeasureMuted(1)) {
            const pitch = measurePitchSelects[0]?.value || 'C4';
            startHum(pitch);
          }
          startBtn.disabled = true; stopBtn.disabled = false;
          doTick();
          if (DEBUG) console.log('Metronome started', { currentBpm, currentMeter, currentSubdivision });
        } catch (err) {
          console.error('Failed to start metronome:', err);
          stopMetronome();
        }
      }
      async function stopMetronome() {
        clearTimeout(timerId);
        isCountingIn = false; // Stop any active count-in
        
        // Remove count-in display if present
        const countInDisplay = document.getElementById('countInDisplay');
        if (countInDisplay) countInDisplay.remove();
        
        startBtn.disabled = false; stopBtn.disabled = true;
        
        // Stop visualization
        stopVisualization();
        
        // Update focus mode button
        if (inFocusMode) {
          focusPlayPause.textContent = '‚ñ∂ Start';
          focusBeatCounter.textContent = '-';
        }
        
        // Clean up any active audio nodes
        if (audioCtx) {
          // Clean up polyrhythm nodes
          scheduledPolyBeats.forEach(node => {
            try {
              if (node.osc) node.osc.stop();
              if (node.gain) node.gain.disconnect();
              if (node.filt) node.filt.disconnect();
            } catch (err) {
              console.error('Error cleaning up poly beat:', err);
            }
          });
          scheduledPolyBeats = [];
          stopHum();

          // Prefer suspend over close to keep context unlocked across starts
          try { await audioCtx.suspend(); } catch {}
        }
        // Clean up notation
        clearNotation();
      }

      /* ---------- Tap tempo ---------- */
      tapBtn.onclick = () => {
        taps.push(Date.now()); if (taps.length > 5) taps.shift();
        if (taps.length > 1) {
          const iv = taps.slice(1).map((t, i) => t - taps[i]);
          bpmInput.value = Math.round(60000 / (iv.reduce((a, b) => a + b) / iv.length));
        }
      };

      /* ---------- Presets ---------- */
      function loadPresets() {
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          presetList.innerHTML = "<option value=''>-- Load Preset --</option>";
          Object.keys(store).forEach(n => presetList.appendChild(new Option(n, n)));
        } catch (err) {
          console.error('Failed to load presets:', err);
          alert('Failed to load presets. Local storage might be corrupted.');
        }
      }
      saveBtn.onclick = () => {
        const name = presetName.value.trim(); 
        if (!name) {
          alert('Please enter a preset name');
          return;
        }
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          if (store[name] && !confirm('A preset with this name already exists. Overwrite?')) {
            return;
          }
          store[name] = {
            bpm: bpmInput.value,
            subdivision: subdivisionSel.value,
            timeSignature: tsSel.value,
            grouping: groupingSel.value,
            tone: toneSel.value,
            volume: volCtrl.value,
            accentTone: accentToneSel.value,
            accentVolume: accentVolCtrl.value,
            subdivisionTone: subToneSel.value,
            subdivisionVolume: subVolCtrl.value,
            swingType: swingTypeSel.value,
            swingAmount: swingAmtCtrl.value,
            tempoChanges,
            playMeasures: +playMeasuresInput.value,
            muteMeasures: +muteMeasuresInput.value,
            drillEnable: !!drillEnableChk.checked,
            drillMeasures: +drillMeasuresInput.value,
            measureCount: +measureCountInput.value,
            measurePitches: measurePitchSelects.map(sel => sel.value),
            humVolume: humVolCtrl.value,
            polyCount: +polyCountInput.value,
            polyTone: polyToneSel.value,
            polyVolume: +polyVolCtrl.value,
            polyEnable: polyEnableChk.checked,
            retainAccents: !!retainAccentsChk.checked,
            checkpointBeep: !!checkpointBeepChk.checked,
            highContrast: !!highContrastChk.checked
          };
          localStorage.setItem('metronomePresets', JSON.stringify(store));
          loadPresets();
          presetName.value = '';
        } catch (err) {
          console.error('Failed to save preset:', err);
          alert('Failed to save preset. Storage might be full or corrupted.');
        }
      };
      loadBtn.onclick = () => {
        const name = presetList.value; if (!name) return;
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          const p = store[name];
          if (!p) {
            console.error('Preset not found:', name);
            return;
          }
          
          // Validate and sanitize loaded values
          bpmInput.value = Math.min(Math.max(30, parseInt(p.bpm) || 100), 300);
          subdivisionSel.value = Math.min(Math.max(1, parseInt(p.subdivision) || 1), 5);
          tsSel.value = p.timeSignature || '4/4';
          groupingSel.value = p.grouping || '';
          toneSel.value = p.tone || 'click';
          volCtrl.value = Math.min(Math.max(0, parseFloat(p.volume) || 1), 1);
          accentToneSel.value = p.accentTone || 'click';
          accentVolCtrl.value = Math.min(Math.max(0, parseFloat(p.accentVolume) || 1), 1);
          subToneSel.value = p.subdivisionTone || 'click';
          subVolCtrl.value = Math.min(Math.max(0, parseFloat(p.subdivisionVolume) || 0.6), 1);
          swingTypeSel.value = p.swingType || 'off';
          swingAmtCtrl.value = Math.min(Math.max(0, parseFloat(p.swingAmount) || 0), 1);
          // Respect explicit 0 and default to 0 if unset
          humVolCtrl.value = Math.min(
            Math.max(
              0,
              (p.humVolume !== undefined && p.humVolume !== null && p.humVolume !== '') ? parseFloat(p.humVolume) : 0
            ),
            1
          );
          tempoChanges = Array.isArray(p.tempoChanges) ? p.tempoChanges : [];
          playMeasuresInput.value = Math.max(0, parseInt(p.playMeasures) || 0);
          muteMeasuresInput.value = Math.max(0, parseInt(p.muteMeasures) || 0);
          drillEnableChk.checked = !!p.drillEnable;
          drillMeasuresInput.value = Math.max(1, parseInt(p.drillMeasures) || 2);

          measureCountInput.value = Math.max(1, parseInt(p.measureCount) || 1);
          renderMeasurePitchControls();
          if (Array.isArray(p.measurePitches)) {
            p.measurePitches.forEach((t, i) => {
              if (measurePitchSelects[i]) measurePitchSelects[i].value = t;
            });
          }

          // Polyrhythm settings
          polyCountInput.value = Math.max(1, parseInt(p.polyCount) || 3);
          polyToneSel.value = p.polyTone || 'click';
          polyVolCtrl.value = Math.min(Math.max(0, parseFloat(p.polyVolume) || 1), 1);
          polyEnableChk.checked = !!p.polyEnable;
          retainAccentsChk.checked = !!p.retainAccents;
          checkpointBeepChk.checked = p.checkpointBeep === undefined ? true : !!p.checkpointBeep;
          highContrastChk.checked = !!p.highContrast;
          document.body.classList.toggle('hc', highContrastChk.checked);
          
          updateGroupingOpts(); 
          updateAccentPattern(); 
          renderTempoChanges();
        } catch (err) {
          console.error('Failed to load preset:', err);
        }
      };
      deleteBtn.onclick = () => {
        const name = presetList.value; 
        if (!name) return;
        if (!confirm('Are you sure you want to delete this preset?')) return;
        try {
          const store = JSON.parse(localStorage.getItem('metronomePresets') || '{}');
          delete store[name];
          localStorage.setItem('metronomePresets', JSON.stringify(store));
          loadPresets();
        } catch (err) {
          console.error('Failed to delete preset:', err);
          alert('Failed to delete preset. Storage might be corrupted.');
        }
      };

      /* ---------- Event hooks ---------- */
      startBtn.onclick = startMetronome;
      stopBtn.onclick = stopMetronome;
      
      // Add keyboard shortcuts
      document.addEventListener('keydown', e => {
        // Only handle if not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        
        switch(e.key.toLowerCase()) {
          case ' ':  // Space bar
            e.preventDefault();
            if (!startBtn.disabled) startMetronome();
            else if (!stopBtn.disabled) stopMetronome();
            break;
          case 't':  // Tap tempo
            e.preventDefault();
            tapBtn.click();
            break;
          case 'arrowup':  // Increase BPM
            e.preventDefault();
            bpmInput.value = Math.min(300, +bpmInput.value + (e.shiftKey ? 10 : 1));
            if (!startBtn.disabled) currentBpm = +bpmInput.value;
            break;
          case 'arrowdown':  // Decrease BPM
            e.preventDefault();
            bpmInput.value = Math.max(30, +bpmInput.value - (e.shiftKey ? 10 : 1));
            if (!startBtn.disabled) currentBpm = +bpmInput.value;
            break;
          case 'escape':  // Stop
            e.preventDefault();
            if (!stopBtn.disabled) stopMetronome();
            break;
        }
      });
      
      // Add input validation
      bpmInput.onchange = () => {
        const val = +bpmInput.value;
        bpmInput.value = Math.min(Math.max(30, val), 300);
      };
      
      playMeasuresInput.onchange = () => {
        const val = +playMeasuresInput.value;
        playMeasuresInput.value = Math.max(0, val);
      };
      
      muteMeasuresInput.onchange = () => {
        const val = +muteMeasuresInput.value;
        muteMeasuresInput.value = Math.max(0, val);
      };
      
      polyCountInput.onchange = () => {
        const val = +polyCountInput.value;
        polyCountInput.value = Math.min(Math.max(1, val), 16);
      };
      
      changeStart.onchange = () => {
        const val = +changeStart.value;
        changeStart.value = Math.max(1, val);
      };
      
      changeBpm.onchange = () => {
        const val = +changeBpm.value;
        changeBpm.value = Math.min(Math.max(30, val), 300);
      };
      
      changeDur.onchange = () => {
        const val = +changeDur.value;
        changeDur.value = Math.max(1, val);
      };

      tsSel.onchange = () => {
        currentMeter = parseInt(tsSel.value.split('/')[0], 10);
        rebuildAccentsPreservingState();
        drawNotation(0);
        // Update beat markers for visualization
        if (visualTypeSel.value === 'ball') {
          updateBeatMarkers();
        }
      };
      
      subdivisionSel.onchange = () => {
        currentSubdivision = +subdivisionSel.value; drawNotation(0);
      };
      swingTypeSel.onchange = () => {
        // Swing applies only to matching subdivisions (8ths or 16ths)
      };
      swingAmtCtrl.oninput = () => {
        // Live; nothing to recompute immediately
      };
      
      groupingSel.onchange = updateAccentPattern;

      measureCountInput.onchange = () => {
        const val = +measureCountInput.value;
        measureCountInput.value = Math.max(1, val);
        renderMeasurePitchControls();
      };

      drillMeasuresInput.onchange = () => {
        const val = +drillMeasuresInput.value;
        drillMeasuresInput.value = Math.max(1, val);
      };

      // Display controls
      highContrastChk.onchange = () => {
        document.body.classList.toggle('hc', highContrastChk.checked);
      };

      // Dark mode toggle
      const darkModeBtn = $('darkModeBtn');
      let darkMode = localStorage.getItem('metronomeDarkMode') === 'true';
      
      function applyDarkMode(enabled) {
        darkMode = enabled;
        document.body.classList.toggle('dark-mode', enabled);
        darkModeBtn.textContent = enabled ? '‚òÄÔ∏è Light' : 'üåô Dark';
        localStorage.setItem('metronomeDarkMode', enabled);
      }
      
      darkModeBtn.onclick = () => applyDarkMode(!darkMode);
      
      // Apply saved dark mode preference on load
      applyDarkMode(darkMode);

      /* ---------- Init ---------- */
      // Keep trying to unlock/resume on any user interaction, not just once
      const unlock = async () => { await ensureAudio(); };
      ['pointerdown','touchstart','keydown'].forEach(evt => {
        window.addEventListener(evt, unlock, { passive: true });
      });
      // Resume when tab regains focus/visibility
      document.addEventListener('visibilitychange', () => { if (!document.hidden) ensureAudio(); });
      window.addEventListener('focus', () => { ensureAudio(); });
      // Recreate audio pipeline on device changes (covers BT HFP<>A2DP profile swaps)
      if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
        navigator.mediaDevices.addEventListener('devicechange', () => {
          if (DEBUG) console.log('Media devices changed, recreating AudioContext');
          recreateAudio();
        });
      }
      loadPresets();
      renderMeasurePitchControls();
      tsSel.dispatchEvent(new Event('change'));
      
      // Initialize beat visualization
      updateVisualization(visualTypeSel.value);

      /* ---------- Rhythm Builder ---------- */
      const rbPattern = [];
      let rbModifiers = { dotted: false, triplet: false, quintuplet: false };
      let rbPlaying = false;
      let rbSchedulerId = null;
      let rbNextNoteTime = 0;
      let rbCurrentIndex = 0;

      const rbPatternList = $('rbPatternList');
      const rbDisplay = $('rbDisplay');
      const rbLibraryGrid = $('rbLibraryGrid');
      const rbLibraryCategory = $('rbLibraryCategory');
      const rbBpmInput = $('rbBpm');
      const rbVolumeCtrl = $('rbVolume');
      const rbLoopChk = $('rbLoop');

      // Note durations in beats
      const noteDurations = {
        'w': 4, 'h': 2, 'q': 1, 'e': 0.5, 's': 0.25
      };

      // Note symbols for display
      const noteSymbols = {
        'w': 'ùÖù', 'h': 'ùÖóùÖ•', 'q': '‚ô©', 'e': '‚ô™', 's': 'ùÖòùÖ•ùÖØ'
      };
      const restSymbols = {
        'w': 'ùÑª', 'h': 'ùÑº', 'q': 'ùÑΩ', 'e': 'ùÑæ', 's': 'ùÑø'
      };

      // Add note to pattern
      function rbAddNote(baseType, isRest = false) {
        let duration = noteDurations[baseType];
        
        // Apply modifiers
        if (rbModifiers.dotted) duration *= 1.5;
        if (rbModifiers.triplet) duration *= 2/3;
        if (rbModifiers.quintuplet) duration *= 4/5;

        rbPattern.push({
          type: isRest ? 'rest' : 'note',
          baseType,
          duration,
          dotted: rbModifiers.dotted,
          triplet: rbModifiers.triplet,
          quintuplet: rbModifiers.quintuplet
        });

        // Reset modifiers after use
        rbModifiers = { dotted: false, triplet: false, quintuplet: false };
        updateModifierButtons();
        rbRenderPattern();
      }

      // Render pattern list
      function rbRenderPattern() {
        if (rbPattern.length === 0) {
          rbPatternList.innerHTML = '<span style="color:#999; font-size:0.9rem;">Click notes above to build your rhythm...</span>';
        } else {
          rbPatternList.innerHTML = rbPattern.map((item, idx) => {
            const symbol = item.type === 'rest' 
              ? restSymbols[item.baseType] 
              : noteSymbols[item.baseType];
            
            let mods = '';
            if (item.dotted) mods += '‚Ä¢';
            if (item.triplet) mods += '¬≥';
            if (item.quintuplet) mods += '‚Åµ';

            const classes = [
              'rb-pattern-item',
              item.type === 'rest' ? 'rest' : '',
              (item.triplet || item.quintuplet) ? 'tuplet' : ''
            ].filter(Boolean).join(' ');

            return `<span class="${classes}">
              ${symbol}${mods}
              <span class="remove" data-idx="${idx}">√ó</span>
            </span>`;
          }).join('');
        }

        // Render VexFlow notation
        rbRenderVexFlow();
      }

      // Render VexFlow notation
      function rbRenderVexFlow() {
        rbDisplay.innerHTML = '';
        if (rbPattern.length === 0) {
          rbDisplay.innerHTML = '<span style="color:#999;">Pattern will appear here</span>';
          return;
        }

        try {
          const { Renderer, Stave, StaveNote, Voice, Formatter, Dot, Tuplet } = Vex.Flow;
          
          const width = rbDisplay.offsetWidth || 400;
          const height = 120;
          
          const renderer = new Renderer(rbDisplay, Renderer.Backends.SVG);
          renderer.resize(width, height);
          const context = renderer.getContext();
          
          const stave = new Stave(10, 10, width - 20);
          stave.addClef('percussion');
          stave.draw(context);

          // Convert pattern to VexFlow notes
          const notes = [];
          const tuplets = [];
          let tupletNotes = [];
          let lastTupletType = null;

          for (const item of rbPattern) {
            // Map duration to VexFlow duration string
            let durStr = { 'w': 'w', 'h': 'h', 'q': 'q', 'e': '8', 's': '16' }[item.baseType];
            if (item.dotted) durStr += 'd';
            
            const isRest = item.type === 'rest';
            const keys = isRest ? ['b/4'] : ['c/5'];
            
            const note = new StaveNote({
              keys,
              duration: durStr + (isRest ? 'r' : ''),
            });

            if (item.dotted) {
              Dot.buildAndAttach([note], { all: true });
            }

            notes.push(note);

            // Handle tuplets
            if (item.triplet) {
              if (lastTupletType !== 'triplet') {
                if (tupletNotes.length > 0) {
                  tuplets.push(new Tuplet(tupletNotes));
                }
                tupletNotes = [];
              }
              tupletNotes.push(note);
              lastTupletType = 'triplet';
            } else if (item.quintuplet) {
              if (lastTupletType !== 'quintuplet') {
                if (tupletNotes.length > 0) {
                  tuplets.push(new Tuplet(tupletNotes));
                }
                tupletNotes = [];
              }
              tupletNotes.push(note);
              lastTupletType = 'quintuplet';
            } else {
              if (tupletNotes.length >= 3 && lastTupletType === 'triplet') {
                tuplets.push(new Tuplet(tupletNotes, { num_notes: 3 }));
                tupletNotes = [];
              } else if (tupletNotes.length >= 5 && lastTupletType === 'quintuplet') {
                tuplets.push(new Tuplet(tupletNotes, { num_notes: 5 }));
                tupletNotes = [];
              }
              lastTupletType = null;
            }
          }

          // Finalize any remaining tuplet
          if (tupletNotes.length >= 3 && lastTupletType === 'triplet') {
            tuplets.push(new Tuplet(tupletNotes, { num_notes: 3 }));
          } else if (tupletNotes.length >= 5 && lastTupletType === 'quintuplet') {
            tuplets.push(new Tuplet(tupletNotes, { num_notes: 5 }));
          }

          // Calculate total beats
          const totalBeats = rbPattern.reduce((sum, item) => sum + item.duration, 0);
          
          // Create voice with calculated duration
          const voice = new Voice({ num_beats: Math.ceil(totalBeats), beat_value: 4 }).setStrict(false);
          voice.addTickables(notes);

          new Formatter().joinVoices([voice]).format([voice], width - 50);
          voice.draw(context, stave);

          // Draw tuplets
          for (const tuplet of tuplets) {
            tuplet.setContext(context).draw();
          }
        } catch (err) {
          console.error('VexFlow render error:', err);
          rbDisplay.innerHTML = '<span style="color:#c00;">Error rendering notation</span>';
        }
      }

      // Update modifier button states
      function updateModifierButtons() {
        $('rbDot').classList.toggle('active', rbModifiers.dotted);
        $('rbTriplet').classList.toggle('active', rbModifiers.triplet);
        $('rbQuint').classList.toggle('active', rbModifiers.quintuplet);
      }

      // Setup note buttons
      document.querySelectorAll('#rbNotes button[data-note]').forEach(btn => {
        btn.onclick = () => rbAddNote(btn.dataset.note, false);
      });

      document.querySelectorAll('#rbRests button[data-rest]').forEach(btn => {
        btn.onclick = () => rbAddNote(btn.dataset.rest, true);
      });

      // Modifier buttons
      $('rbDot').onclick = () => {
        rbModifiers.dotted = !rbModifiers.dotted;
        updateModifierButtons();
      };
      $('rbTriplet').onclick = () => {
        rbModifiers.triplet = !rbModifiers.triplet;
        if (rbModifiers.triplet) rbModifiers.quintuplet = false;
        updateModifierButtons();
      };
      $('rbQuint').onclick = () => {
        rbModifiers.quintuplet = !rbModifiers.quintuplet;
        if (rbModifiers.quintuplet) rbModifiers.triplet = false;
        updateModifierButtons();
      };

      // Undo and Clear
      $('rbUndo').onclick = () => {
        rbPattern.pop();
        rbRenderPattern();
      };
      $('rbClear').onclick = () => {
        if (rbPattern.length === 0 || confirm('Clear the entire pattern?')) {
          rbPattern.length = 0;
          rbRenderPattern();
        }
      };

      // Remove individual notes
      rbPatternList.addEventListener('click', e => {
        if (e.target.classList.contains('remove')) {
          const idx = parseInt(e.target.dataset.idx, 10);
          rbPattern.splice(idx, 1);
          rbRenderPattern();
        }
      });

      // Playback
      function rbScheduleNotes() {
        const bpm = +rbBpmInput.value || 100;
        const beatDuration = 60 / bpm;
        const lookahead = 0.1;
        const scheduleInterval = 25;

        while (rbNextNoteTime < audioCtx.currentTime + lookahead) {
          if (rbCurrentIndex >= rbPattern.length) {
            if (rbLoopChk.checked) {
              rbCurrentIndex = 0;
            } else {
              rbStopPlayback();
              return;
            }
          }

          const item = rbPattern[rbCurrentIndex];
          const duration = item.duration * beatDuration;

          if (item.type === 'note') {
            // Play click sound
            rbPlayClick(rbNextNoteTime);
          }

          rbNextNoteTime += duration;
          rbCurrentIndex++;
        }

        rbSchedulerId = setTimeout(rbScheduleNotes, scheduleInterval);
      }

      function rbPlayClick(time) {
        if (!audioCtx) return;
        const volume = +rbVolumeCtrl.value;
        
        // Use a simple click similar to main metronome
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.frequency.value = 1000;
        gain.gain.setValueAtTime(volume * 0.5, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(time);
        osc.stop(time + 0.05);
      }

      function rbStartPlayback() {
        if (rbPattern.length === 0) {
          alert('Add some notes first!');
          return;
        }
        
        ensureAudio().then(() => {
          rbPlaying = true;
          rbCurrentIndex = 0;
          rbNextNoteTime = audioCtx.currentTime + 0.05;
          rbScheduleNotes();
          $('rbPlay').disabled = true;
          $('rbStop').disabled = false;
        });
      }

      function rbStopPlayback() {
        rbPlaying = false;
        if (rbSchedulerId) {
          clearTimeout(rbSchedulerId);
          rbSchedulerId = null;
        }
        $('rbPlay').disabled = false;
        $('rbStop').disabled = true;
      }

      $('rbPlay').onclick = rbStartPlayback;
      $('rbStop').onclick = rbStopPlayback;
      $('rbStop').disabled = true;

      // Library
      const RhythmLibrary = {
        basic: {
          name: 'Basic Rhythms',
          patterns: [
            { id: 'quarters', name: 'Quarter Notes', description: 'Four quarter notes', difficulty: 1,
              pattern: [
                { type: 'note', baseType: 'q', duration: 1, dotted: false },
                { type: 'note', baseType: 'q', duration: 1, dotted: false },
                { type: 'note', baseType: 'q', duration: 1, dotted: false },
                { type: 'note', baseType: 'q', duration: 1, dotted: false }
              ]
            },
            { id: 'eighths', name: 'Eighth Notes', description: 'Eight eighth notes', difficulty: 1,
              pattern: [
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false }
              ]
            }
          ]
        },
        dotted: {
          name: 'Dotted Rhythms',
          patterns: [
            { id: 'dotted-quarter-eighth', name: 'Dotted Quarter + Eighth', description: 'Classic dotted rhythm', difficulty: 2,
              pattern: [
                { type: 'note', baseType: 'q', duration: 1.5, dotted: true },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'q', duration: 1.5, dotted: true },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false }
              ]
            },
            { id: 'scotch-snap', name: 'Scotch Snap', description: 'Sixteenth + dotted eighth', difficulty: 3,
              pattern: [
                { type: 'note', baseType: 's', duration: 0.25, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.75, dotted: true },
                { type: 'note', baseType: 's', duration: 0.25, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.75, dotted: true },
                { type: 'note', baseType: 's', duration: 0.25, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.75, dotted: true },
                { type: 'note', baseType: 's', duration: 0.25, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.75, dotted: true }
              ]
            }
          ]
        },
        syncopation: {
          name: 'Syncopation',
          patterns: [
            { id: 'offbeat-eighths', name: 'Offbeat Eighths', description: 'All notes on the "and"', difficulty: 3,
              pattern: [
                { type: 'rest', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'rest', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'rest', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'rest', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false }
              ]
            },
            { id: 'tresillo', name: 'Tresillo', description: '3+3+2 pattern', difficulty: 3,
              pattern: [
                { type: 'note', baseType: 'q', duration: 1.5, dotted: true },
                { type: 'note', baseType: 'q', duration: 1.5, dotted: true },
                { type: 'note', baseType: 'q', duration: 1, dotted: false }
              ]
            }
          ]
        },
        triplets: {
          name: 'Triplets',
          patterns: [
            { id: 'eighth-triplets', name: 'Eighth Triplets', description: 'Three in the space of two', difficulty: 2,
              pattern: Array(12).fill(null).map(() => ({ 
                type: 'note', baseType: 'e', duration: 1/3, dotted: false, triplet: true 
              }))
            }
          ]
        },
        latin: {
          name: 'Latin Rhythms',
          patterns: [
            { id: 'bossa', name: 'Bossa Nova', description: 'Brazilian rhythm', difficulty: 4,
              pattern: [
                { type: 'note', baseType: 'q', duration: 1.5, dotted: true },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'rest', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'e', duration: 0.5, dotted: false },
                { type: 'note', baseType: 'q', duration: 1, dotted: false }
              ]
            }
          ]
        }
      };

      // Render library patterns
      rbLibraryCategory.onchange = () => {
        const cat = rbLibraryCategory.value;
        if (!cat || !RhythmLibrary[cat]) {
          rbLibraryGrid.innerHTML = '';
          return;
        }

        const patterns = RhythmLibrary[cat].patterns;
        rbLibraryGrid.innerHTML = patterns.map(p => `
          <div class="rb-library-item" data-pattern-id="${p.id}">
            <div class="name">${p.name}</div>
            <div class="desc">${p.description}</div>
            <div class="difficulty">${'‚òÖ'.repeat(p.difficulty)}</div>
          </div>
        `).join('');
      };

      // Load pattern from library
      rbLibraryGrid.addEventListener('click', e => {
        const item = e.target.closest('.rb-library-item');
        if (!item) return;

        const cat = rbLibraryCategory.value;
        const patternId = item.dataset.patternId;
        const patternData = RhythmLibrary[cat]?.patterns.find(p => p.id === patternId);

        if (patternData) {
          // Copy pattern data
          rbPattern.length = 0;
          patternData.pattern.forEach(p => rbPattern.push({ ...p }));
          rbRenderPattern();
        }
      });

      /* ---------- Tap-to-Rhythm ---------- */
      const rbTapBtn = $('rbTapBtn');
      const rbTapInfo = $('rbTapInfo');
      const rbTapStart = $('rbTapStart');
      const rbTapStop = $('rbTapStop');
      const rbTapApply = $('rbTapApply');
      const rbTapQuantize = $('rbTapQuantize');
      const rbTapBpm = $('rbTapBpm');
      
      let tapRecording = false;
      let tapTimestamps = [];
      let tapIntervals = [];

      function startTapRecording() {
        tapRecording = true;
        tapTimestamps = [];
        tapIntervals = [];
        rbTapBtn.classList.add('recording');
        rbTapBtn.textContent = 'TAP!';
        rbTapInfo.textContent = 'Tap the button or press SPACE to record...';
        rbTapStart.disabled = true;
        rbTapStop.disabled = false;
        rbTapApply.disabled = true;
      }

      function stopTapRecording() {
        tapRecording = false;
        rbTapBtn.classList.remove('recording');
        rbTapBtn.textContent = 'TAP\nRHYTHM';
        rbTapStart.disabled = false;
        rbTapStop.disabled = true;
        
        if (tapTimestamps.length >= 2) {
          // Calculate intervals
          tapIntervals = [];
          for (let i = 1; i < tapTimestamps.length; i++) {
            tapIntervals.push(tapTimestamps[i] - tapTimestamps[i - 1]);
          }
          rbTapInfo.textContent = `Recorded ${tapTimestamps.length} taps. Click Apply to convert.`;
          rbTapApply.disabled = false;
        } else {
          rbTapInfo.textContent = 'Need at least 2 taps. Try again.';
          rbTapApply.disabled = true;
        }
      }

      function recordTap() {
        if (!tapRecording) return;
        
        const now = performance.now();
        tapTimestamps.push(now);
        
        // Visual feedback
        rbTapBtn.classList.add('tapping');
        setTimeout(() => rbTapBtn.classList.remove('tapping'), 100);
        
        // Play click sound
        if (audioCtx) {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.frequency.value = 800;
          gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.05);
        }
        
        rbTapInfo.textContent = `Taps: ${tapTimestamps.length}`;
      }

      function applyTappedRhythm() {
        if (tapIntervals.length === 0) return;
        
        const referenceBpm = +rbTapBpm.value || 100;
        const beatDurationMs = 60000 / referenceBpm;
        const quantizeLevel = +rbTapQuantize.value;
        
        // Convert intervals to beat durations
        const durations = tapIntervals.map(interval => interval / beatDurationMs);
        
        // Quantize if requested
        const quantizedDurations = durations.map(dur => {
          if (quantizeLevel === 0) return dur;
          
          const subdivision = 4 / quantizeLevel; // e.g., 16ths = 0.25 beats
          return Math.round(dur / subdivision) * subdivision;
        });
        
        // Convert to note types
        rbPattern.length = 0;
        
        for (const dur of quantizedDurations) {
          const note = durationToNote(dur);
          rbPattern.push(note);
        }
        
        rbRenderPattern();
        rbTapInfo.textContent = `Converted ${tapIntervals.length} intervals to notes.`;
        rbTapApply.disabled = true;
      }

      function durationToNote(duration) {
        // Map duration (in beats) to closest note type
        // 4 = whole, 2 = half, 1 = quarter, 0.5 = eighth, 0.25 = sixteenth
        
        const noteTypes = [
          { type: 'w', dur: 4, dotted: false },
          { type: 'h', dur: 3, dotted: true },  // dotted half
          { type: 'h', dur: 2, dotted: false },
          { type: 'q', dur: 1.5, dotted: true }, // dotted quarter
          { type: 'q', dur: 1, dotted: false },
          { type: 'e', dur: 0.75, dotted: true }, // dotted eighth
          { type: 'e', dur: 0.5, dotted: false },
          { type: 's', dur: 0.25, dotted: false }
        ];
        
        // Find closest match
        let closest = noteTypes[0];
        let minDiff = Math.abs(duration - closest.dur);
        
        for (const nt of noteTypes) {
          const diff = Math.abs(duration - nt.dur);
          if (diff < minDiff) {
            minDiff = diff;
            closest = nt;
          }
        }
        
        return {
          type: 'note',
          baseType: closest.type,
          duration: closest.dur,
          dotted: closest.dotted
        };
      }

      rbTapBtn.onmousedown = recordTap;
      rbTapBtn.ontouchstart = (e) => { e.preventDefault(); recordTap(); };
      
      rbTapStart.onclick = () => {
        ensureAudio();
        startTapRecording();
      };
      rbTapStop.onclick = stopTapRecording;
      rbTapApply.onclick = applyTappedRhythm;
      
      // Also allow spacebar for tapping when recording
      document.addEventListener('keydown', e => {
        if (e.code === 'Space' && tapRecording && 
            !['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
          e.preventDefault();
          recordTap();
        }
      });

      // Initial render
      rbRenderPattern();
    });
  </script>

  <!-- Focus Mode Overlay -->
  <div class="focus-mode" id="focusMode" style="display:none;">
    <div class="focus-visualizer" id="focusVisualizer">
      <!-- Visualization will be moved here when in focus mode -->
    </div>
    <div class="focus-info">
      <div class="focus-beat-counter" id="focusBeatCounter">-</div>
      <div class="focus-bpm-controls">
        <button class="focus-bpm-btn" id="focusBpmDown" aria-label="Decrease BPM">‚àí</button>
        <div class="focus-bpm" id="focusBpm">100</div>
        <button class="focus-bpm-btn" id="focusBpmUp" aria-label="Increase BPM">+</button>
      </div>
      <div class="focus-meter" id="focusMeter">4/4</div>
    </div>
    <div class="focus-controls">
      <button class="focus-playpause" id="focusPlayPause">‚ñ∂ Start</button>
      <button class="focus-exit" id="focusExit">‚úï Exit</button>
    </div>
  </div>
</body>
</html>